{"version":3,"file":"513.f5749b8d6a5fba145786.js","mappings":"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","sources":["webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/jsparser.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/token.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/tokenizer.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/vm.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/errors.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/compiler.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/helpers.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/propertyescapes.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/tape.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/core.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/flexparser.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/charclasses.js","webpack://tlex/./node_modules/.pnpm/tlex@file+../node_modules/tlex/lib/esm/builder.js"],"sourcesContent":["import * as TSU from \"@panyam/tsutils\";\nimport { Quant, RegexType, StartOfInput, EndOfInput, Cat, LeafChar, CharGroup, CharType, Var, BackNamedRef, BackNumRef, LookAhead, LookBack, Union, } from \"./core\";\nimport { CharClassType } from \"./charclasses\";\nimport { GroupCounter } from \"./utils\";\nexport class RegexParser {\n    constructor(pattern, config) {\n        this.pattern = pattern;\n        this.counter = new GroupCounter();\n        this.unicode = config?.unicode || false;\n    }\n    reduceLeft(stack) {\n        const r = stack.length == 1 ? stack[0] : new Cat(...stack);\n        stack.splice(0);\n        return r;\n    }\n    throwError(msg) {\n        throw new SyntaxError(`Error in JS RE '${this.pattern}': ${msg}`);\n    }\n    parse(curr = 0, end = -1) {\n        const pattern = this.pattern;\n        const stack = [];\n        if (end < 0)\n            end = pattern.length - 1;\n        while (curr <= end) {\n            const currCh = pattern[curr];\n            if (currCh == \".\") {\n                stack.push(LeafChar.Any());\n                curr++;\n            }\n            else if (currCh == \"\\\\\" && pattern[curr + 1] >= \"1\" && pattern[curr + 1] <= \"9\") {\n                curr++;\n                let num = \"\";\n                while (curr <= end && pattern[curr] >= \"0\" && pattern[curr] <= \"9\") {\n                    num = num + pattern[curr++];\n                }\n                const refNum = parseInt(num);\n                if (refNum > this.counter.current + 1) {\n                    this.throwError(\"Invalid reference: \" + refNum);\n                }\n                stack.push(new BackNumRef(refNum));\n            }\n            else if (currCh == \"\\\\\" && pattern[curr + 1] == \"k\" && pattern[curr + 2] == \"<\") {\n                curr += 3;\n                let gtPos = curr;\n                while (gtPos <= end && pattern[gtPos] != \">\")\n                    gtPos++;\n                if (gtPos > end)\n                    this.throwError(\"Expected '>' found EOI\");\n                const name = pattern.substring(curr, gtPos);\n                if (name.trim() == \"\") {\n                    this.throwError(\"Expected name\");\n                }\n                stack.push(new BackNamedRef(name));\n                curr = gtPos + 1;\n            }\n            else if (currCh == \"[\") {\n                let clPos = curr + 1;\n                while (clPos <= end && pattern[clPos] != \"]\") {\n                    if (pattern[clPos] == \"\\\\\")\n                        clPos++;\n                    clPos++;\n                }\n                if (clPos > end)\n                    this.throwError(\"Expected ']' found EOI\");\n                stack.push(this.parseCharGroup(curr + 1, clPos - 1));\n                curr = clPos + 1;\n            }\n            else if (currCh == \"^\") {\n                stack.push(new StartOfInput());\n                curr++;\n            }\n            else if (currCh == \"$\") {\n                stack.push(new EndOfInput());\n                curr++;\n            }\n            else if (currCh == \"|\") {\n                if (curr + 1 <= end) {\n                    const prev = this.reduceLeft(stack);\n                    const rest = this.parse(curr + 1, end);\n                    return new Union(prev, rest);\n                }\n                curr = end + 1;\n            }\n            else if (currCh == \"(\") {\n                curr = this.parseGroup(stack, curr, end);\n            }\n            else if (currCh == \")\" || currCh == \"]\" || currCh == \"}\") {\n                this.throwError(`Unmatched ${currCh}.  Try using \\\\${currCh}`);\n            }\n            else if (pattern[curr] == \"*\" || pattern[curr] == \"?\" || pattern[curr] == \"+\" || pattern[curr] == \"{\") {\n                curr = this.parseQuant(stack, curr, end);\n            }\n            else {\n                const [result, nchars] = this.parseChar(curr, end);\n                stack.push(result);\n                curr += nchars;\n            }\n        }\n        if (stack.length <= 0) {\n        }\n        if (stack.length == 1)\n            return stack[0];\n        return new Cat(...stack);\n    }\n    parseGroup(stack, curr, end) {\n        let clPos = curr + 1;\n        let depth = 0;\n        const pattern = this.pattern;\n        while (clPos <= end && (pattern[clPos] != \")\" || depth > 0)) {\n            if (pattern[clPos] == \"(\")\n                depth++;\n            else if (pattern[clPos] == \")\")\n                depth--;\n            if (pattern[clPos] == \"\\\\\")\n                clPos++;\n            clPos++;\n        }\n        if (clPos > end)\n            this.throwError(\"Expected ')' found EOI\");\n        curr++;\n        if (pattern[curr] == \"?\") {\n            curr++;\n            if (pattern[curr] == \":\") {\n                stack.push(this.parse(curr + 1, clPos - 1));\n            }\n            else if (pattern[curr] == \"<\" && pattern[curr + 1] != \"!\" && pattern[curr + 1] != \"=\") {\n                const groupIndex = this.counter.next();\n                let groupName = \"\";\n                let gtPos = curr + 1;\n                while (gtPos <= end && pattern[gtPos] != \">\") {\n                    groupName += pattern[gtPos];\n                    gtPos++;\n                }\n                const subExpr = this.parse(gtPos + 1, clPos - 1);\n                subExpr.groupIndex = groupIndex;\n                if (groupName.length > 0)\n                    subExpr.groupName = groupName;\n            }\n            else {\n                let after = true;\n                if (pattern[curr] == \"<\") {\n                    curr++;\n                    after = false;\n                }\n                const neg = pattern[curr++] == \"!\";\n                const cond = this.parse(curr, clPos - 1);\n                if (after) {\n                    if (stack.length == 0) {\n                    }\n                    const expr = new LookAhead(this.reduceLeft(stack), cond, neg);\n                    stack.push(expr);\n                }\n                else {\n                    const rest = this.parse(clPos + 1, end);\n                    if (rest.groupIndex < 0) {\n                        rest.groupIndex = this.counter.next();\n                        rest.groupIsSilent = true;\n                    }\n                    stack.push(new LookBack(rest, cond, neg));\n                    return end + 1;\n                }\n            }\n        }\n        else {\n            const groupIndex = this.counter.next();\n            let neg = false;\n            if (pattern[curr] == \"^\") {\n                neg = true;\n                curr++;\n            }\n            let subExpr = this.parse(curr, clPos - 1);\n            if (subExpr.groupIndex >= 0) {\n                subExpr = new Cat(subExpr);\n            }\n            subExpr.groupIndex = groupIndex;\n            stack.push(subExpr);\n        }\n        return clPos + 1;\n    }\n    parseCharGroup(curr, end) {\n        const out = [];\n        let i = curr;\n        let neg = false;\n        const pattern = this.pattern;\n        if (pattern[i] == \"^\") {\n            neg = true;\n            i++;\n        }\n        for (; i <= end;) {\n            const [currch, nchars] = this.parseChar(i, end);\n            i += nchars;\n            if (i < pattern.length && pattern[i] == \"-\") {\n                i++;\n                if (pattern[i] == \"]\" || pattern[i] == \"[\") {\n                    out.push(currch);\n                    out.push(LeafChar.Single(\"-\"));\n                }\n                else if (i <= end) {\n                    const [endch, nchars] = this.parseChar(i, end);\n                    if (currch.op != CharType.SingleChar || endch.op != CharType.SingleChar) {\n                        this.throwError(\"Char range cannot start or end in a char class\");\n                    }\n                    if (endch.args[0] < currch.args[0]) {\n                        this.throwError(\"End cannot be less than start\");\n                    }\n                    out.push(CharGroup.Range(currch, endch));\n                    i += nchars;\n                }\n                else {\n                    this.throwError(\"Unterminated char class\");\n                }\n            }\n            else {\n                out.push(currch);\n            }\n        }\n        return CharGroup.Union(neg, out);\n    }\n    parseChar(index = 0, end = 0) {\n        if (this.pattern[index] == \"\\\\\") {\n            return this.parseEscapeChar(index, end);\n        }\n        else {\n            return this.parseSingleChar(index, end);\n        }\n    }\n    parseSingleChar(index = 0, end = 0) {\n        const ch = this.pattern.charCodeAt(index);\n        return [LeafChar.Single(ch), 1];\n    }\n    parsePropertyEscape(index = 0, end = 0) {\n        const pattern = this.pattern;\n        if (pattern[index] + 1 != \"{\") {\n            this.throwError(\"Invalid property escape\");\n        }\n        index += 2;\n        let clEnd = index;\n        let eqPos = -1;\n        while (clEnd <= end && pattern[clEnd] != \"}\") {\n            if (pattern[clEnd] == \"=\")\n                eqPos = clEnd;\n            clEnd++;\n        }\n        if (clEnd > end) {\n            this.throwError(\"Invalid property escape\");\n        }\n        const propStr = pattern.substring(index, clEnd);\n        let propName = \"General_Category\";\n        let propValue = propStr;\n        if (eqPos >= 0) {\n            const parts = propStr.split(\"=\");\n            if (parts.length != 2)\n                this.throwError(\"Invalid property escape\");\n            propName = parts[0].trim();\n            propValue = parts[1].trim();\n        }\n        return [LeafChar.PropertyEscape(propName, propValue), 2 + clEnd + 1 - index];\n    }\n    parseEscapeChar(index = 0, end = 0) {\n        const pattern = this.pattern;\n        TSU.assert(pattern[index] == \"\\\\\", \"Expected '\\\\'\");\n        index++;\n        if (index > end) {\n            this.throwError(\"Encounted unexpected end of input after \\\\\");\n        }\n        const ch = pattern[index];\n        if ((this.unicode && ch == \"p\") || ch == \"P\") {\n            return this.parsePropertyEscape(index, end);\n        }\n        switch (ch) {\n            case \"w\":\n                return [LeafChar.Class(CharClassType.WORD_CHAR), 2];\n            case \"W\":\n                return [LeafChar.Class(CharClassType.WORD_CHAR, true), 2];\n            case \"d\":\n                return [LeafChar.Class(CharClassType.DIGITS), 2];\n            case \"D\":\n                return [LeafChar.Class(CharClassType.DIGITS, true), 2];\n            case \"s\":\n                return [LeafChar.Class(CharClassType.SPACES), 2];\n            case \"S\":\n                return [LeafChar.Class(CharClassType.SPACES, true), 2];\n            case \"0\":\n                if (pattern[index + 1] >= \"0\" && pattern[index + 1] <= \"9\" && this.unicode) {\n                    this.throwError(\"Invalid decimal escape\");\n                }\n                return [LeafChar.Single(\"\\0\"), 2];\n            case \"r\":\n                return [LeafChar.Single(\"\\r\"), 2];\n            case \"n\":\n                return [LeafChar.Single(\"\\n\"), 2];\n            case \"f\":\n                return [LeafChar.Single(\"\\f\"), 2];\n            case \"b\":\n                return [LeafChar.Single(\"\\b\"), 2];\n            case \"v\":\n                return [LeafChar.Single(\"\\v\"), 2];\n            case \"t\":\n                return [LeafChar.Single(\"\\t\"), 2];\n            case \"c\":\n                if (this.unicode || index >= end) {\n                    this.throwError(`Invalid char sequence at ${index}, ${end}`);\n                }\n                const next = pattern.charCodeAt(index + 1) % 32;\n                return [LeafChar.Single(next), 3];\n            case \"x\":\n                index++;\n                if (index >= end) {\n                    this.throwError(`Invalid hex sequence at ${index}, ${end}`);\n                }\n                const hexSeq = pattern.substring(index, index + 2);\n                const hexVal = parseInt(hexSeq, 16);\n                TSU.assert(!isNaN(hexVal), `Invalid hex sequence: '${hexSeq}'`);\n                return [LeafChar.Single(hexVal), 4];\n            case \"u\":\n                index++;\n                if (index > end - 3) {\n                    this.throwError(`Invalid unicode sequence at ${index}`);\n                }\n                const ucodeSeq = pattern.substring(index, index + 4);\n                const ucodeVal = parseInt(ucodeSeq, 16);\n                if (isNaN(ucodeVal)) {\n                    this.throwError(`Invalid unicode sequence: '${ucodeSeq}'`);\n                }\n                return [LeafChar.Single(ucodeVal), 6];\n            case \"^\":\n            case \"$\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"\\\\\":\n            case \"'\":\n            case '\"':\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"]\":\n            case \"{\":\n            case \"}\":\n            case \"|\":\n            case \"/\":\n                return [LeafChar.Single(ch), 2];\n            default:\n                if (this.unicode)\n                    this.throwError(\"Invalid escape character: \" + ch);\n                return [LeafChar.Single(ch), 2];\n        }\n    }\n    parseQuant(stack, curr, end) {\n        const pattern = this.pattern;\n        const lastCh = pattern[curr - 1];\n        let minCount = 1, maxCount = 1;\n        if (pattern[curr] == \"*\") {\n            minCount = 0;\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (pattern[curr] == \"+\") {\n            minCount = Math.min(minCount, 1);\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (pattern[curr] == \"?\") {\n            minCount = 0;\n            maxCount = Math.max(maxCount, 1);\n        }\n        else if (pattern[curr] == \"{\") {\n            const clPos = pattern.indexOf(\"}\", curr + 1);\n            if (clPos <= curr || clPos > end) {\n                this.throwError(\"Unexpected end of input while looking for '}'\");\n            }\n            const sub = pattern.substring(curr + 1, clPos).trim();\n            const parts = sub.split(\",\").map((x) => parseInt(x.trim()));\n            curr = clPos;\n            if (parts.length == 1) {\n                if (isNaN(parts[0])) {\n                    if (sub.trim().length > 0) {\n                        stack.push(new Var(sub.trim()));\n                        return curr + 1;\n                    }\n                    else {\n                        this.throwError(`Invalid quantifier: /${sub}/`);\n                    }\n                }\n                minCount = maxCount = parts[0];\n            }\n            else if (parts.length == 2) {\n                minCount = isNaN(parts[0]) ? 0 : parts[0];\n                maxCount = isNaN(parts[1]) ? TSU.Constants.MAX_INT : parts[1];\n                if (minCount > maxCount) {\n                    this.throwError(`Invalid Quant /${sub}/: Min must be <= Max`);\n                }\n            }\n            else if (parts.length > 2) {\n                this.throwError(`Invalid quantifier spec: \"{${sub}}\"`);\n            }\n        }\n        else {\n            throw new Error(\"Here?\");\n        }\n        if (stack.length <= 0) {\n            this.throwError(\"Quantifier cannot appear before an expression\");\n        }\n        const last = stack[stack.length - 1];\n        if (last.tag == RegexType.QUANT && (lastCh == \"*\" || lastCh == \"?\" || lastCh == \"+\" || lastCh == \"}\")) {\n            this.throwError(\"Nothing to repeat\");\n        }\n        if (this.unicode && (last.tag == RegexType.LOOK_AHEAD || last.tag == RegexType.LOOK_BACK)) {\n            this.throwError(\"Cannot have quantifier on assertion in unicode mode\");\n        }\n        const quant = (stack[stack.length - 1] = new Quant(last));\n        quant.minCount = minCount;\n        quant.maxCount = maxCount;\n        curr++;\n        if (curr <= end && pattern[curr] == \"?\" && quant.greedy) {\n            curr++;\n            quant.greedy = false;\n        }\n        return curr;\n    }\n}\n//# sourceMappingURL=jsparser.js.map","import { TokenizerError, UnexpectedTokenError } from \"./errors\";\nexport class Token {\n    constructor(tag, matchIndex, start, end) {\n        this.tag = tag;\n        this.matchIndex = matchIndex;\n        this.start = start;\n        this.end = end;\n        this.id = Token.idCounter++;\n        this.value = null;\n        this.groups = {};\n        this.positions = {};\n        this.state = 0;\n        this.lookahead = 1;\n        this.lookback = 1;\n    }\n    isOneOf(...expected) {\n        for (const tok of expected) {\n            if (this.tag == tok) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nToken.idCounter = 0;\nexport class TokenBuffer {\n    constructor(nextToken, tokenizerContext) {\n        this.nextToken = nextToken;\n        this.tokenizerContext = tokenizerContext;\n        this.buffer = [];\n    }\n    next(tape) {\n        const out = this.peek(tape);\n        if (out != null) {\n            this.consume();\n        }\n        return out;\n    }\n    peek(tape, nth = 0) {\n        while (this.buffer.length <= nth) {\n            const tok = this.nextToken(tape, this.tokenizerContext);\n            if (tok == null)\n                return null;\n            this.buffer.push(tok);\n        }\n        return this.buffer[nth];\n    }\n    match(tape, matchFunc, ensure = false, consume = true, nextAction) {\n        const token = this.peek(tape);\n        if (token != null) {\n            if (matchFunc(token)) {\n                if (nextAction && nextAction != null) {\n                    nextAction(token);\n                }\n                if (consume) {\n                    this.consume();\n                }\n            }\n            else if (ensure) {\n                throw new UnexpectedTokenError(token);\n            }\n            else {\n                return null;\n            }\n        }\n        else if (ensure) {\n            throw new TokenizerError(\"Unexpected end of input\", -1, 0, \"UnexpectedEndOfInput\");\n        }\n        return token;\n    }\n    consume() {\n        this.buffer.splice(0, 1);\n    }\n    consumeIf(tape, ...expected) {\n        return this.match(tape, (t) => t.isOneOf(...expected));\n    }\n    expectToken(tape, ...expected) {\n        return this.match(tape, (t) => t.isOneOf(...expected), true, true);\n    }\n    ensureToken(tape, ...expected) {\n        return this.match(tape, (t) => t.isOneOf(...expected), true, false);\n    }\n    nextMatches(tape, ...expected) {\n        const token = this.peek(tape);\n        if (token == null)\n            return null;\n        for (const tok of expected) {\n            if (token.tag == tok)\n                return token;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=token.js.map","import { Union } from \"./core\";\nimport { VM } from \"./vm\";\nimport { Compiler } from \"./compiler\";\nimport { Tape as DefaultTape } from \"./tape\";\nimport { TokenizerError } from \"./errors\";\nimport * as Builder from \"./builder\";\nimport { Token } from \"./token\";\nexport function toToken(tag, m, tape) {\n    const out = new Token(tag, m.matchIndex, m.start, m.end);\n    for (let i = 0; i < m.positions.length; i += 2) {\n        if (m.positions[i] >= 0) {\n            out.positions[Math.floor(i / 2)] = [m.positions[i], m.positions[i + 1]];\n        }\n    }\n    for (const [groupIndex, tapeIndex] of m.groups) {\n        const gi = Math.abs(groupIndex);\n        if (!(gi in out.groups)) {\n            out.groups[gi] = [];\n        }\n        out.groups[gi].push(tapeIndex);\n    }\n    if (tape != null)\n        out.value = tape.substring(m.start, m.end);\n    return out;\n}\nexport class BaseTokenizer {\n    constructor() {\n        this._prog = null;\n        this._vm = null;\n        this.onError = null;\n        this.allRules = [];\n        this.onMatchHandlers = [];\n        this.matchHandlersByValue = {};\n        this.variables = new Map();\n        this.compiler = new Compiler((name) => {\n            let out = this.variables.get(name) || null;\n            if (out == null)\n                out = this.findRuleByValue(name)?.expr || null;\n            if (out == null)\n                throw new Error(`Invalid regex reference: ${name}`);\n            return out;\n        });\n    }\n    getVar(name) {\n        return this.variables.get(name) || null;\n    }\n    addVar(name, regex) {\n        let currValue = this.variables.get(name) || null;\n        if (currValue == null) {\n            currValue = regex;\n        }\n        else {\n            currValue = new Union(currValue, regex);\n        }\n        this.variables.set(name, regex);\n        return this;\n    }\n    findRuleByValue(value) {\n        return this.allRules.find((r) => r.tag == value) || null;\n    }\n    add(pattern, config, onMatch = null) {\n        if (typeof config === \"function\") {\n            onMatch = config;\n            config = null;\n        }\n        return this.addRule(Builder.build(pattern, config), onMatch);\n    }\n    addRule(rule, onMatch = null) {\n        rule.matchIndex = this.allRules.length;\n        this.allRules.push(rule);\n        this.onMatchHandlers.push(onMatch);\n        this._prog = null;\n        this._vm = null;\n        return this;\n    }\n    on(tag, onMatch) {\n        this.matchHandlersByValue[tag] = onMatch;\n        return this;\n    }\n    get prog() {\n        if (this._prog == null) {\n            const sortedRules = this.sortRules();\n            this._prog = this.compiler.compile(sortedRules);\n        }\n        return this._prog;\n    }\n    get vm() {\n        if (this._vm == null) {\n            this._vm = new VM(this.prog);\n        }\n        return this._vm;\n    }\n    sortRules() {\n        const sortedRules = this.allRules.map((rule) => rule);\n        sortedRules.sort((r1, r2) => {\n            if (r1.priority != r2.priority)\n                return r2.priority - r1.priority;\n            return r1.matchIndex - r2.matchIndex;\n        });\n        return sortedRules;\n    }\n}\nexport class Tokenizer extends BaseTokenizer {\n    constructor() {\n        super(...arguments);\n        this.idCounter = 0;\n    }\n    getState() {\n        return this.vm.getState();\n    }\n    setState(state) {\n        this.vm.setState(state);\n    }\n    reset() {\n        this.idCounter = 0;\n        if (this._vm) {\n            this._vm.setState(0);\n        }\n    }\n    next(tape, owner) {\n        if (!tape.hasMore) {\n            return null;\n        }\n        const startIndex = tape.index;\n        const startChar = tape.currCh;\n        const m = this.vm.match(tape);\n        if (m == null) {\n            let err = null;\n            if (tape.index == startIndex + 1) {\n                err = new TokenizerError(`Unexpected Character: ${startChar}`, startIndex, 1, \"UnexpectedCharacter\", startChar);\n            }\n            else {\n                err = new TokenizerError(`Unexpected Symbol: ${tape.substring(startIndex, tape.index)}`, startIndex, tape.index - startIndex, \"UnexpectedLexeme\");\n            }\n            if (this.onError) {\n                err = this.onError(err, tape, startIndex);\n            }\n            if (err != null) {\n                throw err;\n            }\n            else {\n                return this.next(tape, owner);\n            }\n        }\n        const rule = this.allRules[m.matchIndex];\n        let token = toToken(rule.tag, m, tape);\n        token.id = this.idCounter++;\n        let onMatch = this.onMatchHandlers[m.matchIndex];\n        if (!onMatch) {\n            onMatch = this.matchHandlersByValue[rule.tag];\n        }\n        if (onMatch) {\n            token = onMatch(rule, tape, token, owner);\n            if (token == null) {\n                return this.next(tape, owner);\n            }\n        }\n        else if (rule.skip) {\n            return this.next(tape, owner);\n        }\n        return token;\n    }\n    tokenize(tape, owner = null) {\n        const tokens = [];\n        if (typeof tape === \"string\") {\n            tape = new DefaultTape(tape);\n        }\n        let next = this.next(tape, owner);\n        while (next) {\n            tokens.push(next);\n            try {\n                next = this.next(tape, owner);\n            }\n            catch (err) {\n                tokens.push({\n                    tag: \"ERROR\",\n                    start: err.offset,\n                    end: err.offset + err.length,\n                    value: err.message,\n                });\n                break;\n            }\n        }\n        return tokens;\n    }\n}\n//# sourceMappingURL=tokenizer.js.map","import * as TSU from \"@panyam/tsutils\";\nfunction isNewLineChar(ch) {\n    return ch == \"\\r\" || ch == \"\\n\" || ch == \"\\u2028\" || ch == \"\\u2029\";\n}\nexport class Match {\n    constructor(priority = 10, matchIndex = -1, start = -1, end = -1) {\n        this.priority = priority;\n        this.matchIndex = matchIndex;\n        this.start = start;\n        this.end = end;\n        this.groups = [];\n        this.positions = [];\n    }\n}\nexport var OpCode;\n(function (OpCode) {\n    OpCode[OpCode[\"Any\"] = 0] = \"Any\";\n    OpCode[OpCode[\"AnyNonNL\"] = 1] = \"AnyNonNL\";\n    OpCode[OpCode[\"Char\"] = 2] = \"Char\";\n    OpCode[OpCode[\"CIChar\"] = 3] = \"CIChar\";\n    OpCode[OpCode[\"Match\"] = 4] = \"Match\";\n    OpCode[OpCode[\"Noop\"] = 5] = \"Noop\";\n    OpCode[OpCode[\"Save\"] = 6] = \"Save\";\n    OpCode[OpCode[\"Split\"] = 7] = \"Split\";\n    OpCode[OpCode[\"Jump\"] = 8] = \"Jump\";\n    OpCode[OpCode[\"Begin\"] = 9] = \"Begin\";\n    OpCode[OpCode[\"RBegin\"] = 10] = \"RBegin\";\n    OpCode[OpCode[\"End\"] = 11] = \"End\";\n    OpCode[OpCode[\"StartingChar\"] = 12] = \"StartingChar\";\n    OpCode[OpCode[\"EndingChar\"] = 13] = \"EndingChar\";\n    OpCode[OpCode[\"MLStartingChar\"] = 14] = \"MLStartingChar\";\n    OpCode[OpCode[\"MLEndingChar\"] = 15] = \"MLEndingChar\";\n    OpCode[OpCode[\"StartOfWord\"] = 16] = \"StartOfWord\";\n    OpCode[OpCode[\"EndOfWord\"] = 17] = \"EndOfWord\";\n    OpCode[OpCode[\"GroupStart\"] = 18] = \"GroupStart\";\n    OpCode[OpCode[\"GroupEnd\"] = 19] = \"GroupEnd\";\n    OpCode[OpCode[\"EnsureState\"] = 20] = \"EnsureState\";\n})(OpCode || (OpCode = {}));\nexport class Prog {\n    constructor(startCondition = \"INITIAL\", scIsInclusive = true) {\n        this.startCondition = startCondition;\n        this.scIsInclusive = scIsInclusive;\n        this.instrs = [];\n        this.stateMapping = new Map();\n        this.registerState(\"INITIAL\");\n        this.registerState(startCondition);\n    }\n    get length() {\n        return this.instrs.length;\n    }\n    registerState(state) {\n        if (!this.stateMapping.has(state)) {\n            this.stateMapping.set(state, this.stateMapping.size);\n        }\n        return this.stateMapping.get(state) || -1;\n    }\n    add(opcode, char = null, ...args) {\n        const out = new Instr(opcode, char).add(...args);\n        out.offset = this.instrs.length;\n        this.instrs.push(out);\n        return out;\n    }\n    static with(initializer) {\n        const out = new Prog();\n        initializer(out);\n        return out;\n    }\n    debugValue(instrDebugValue = InstrDebugValue) {\n        if (instrDebugValue) {\n            return this.instrs.map((instr, index) => {\n                if (instr.comment.trim().length > 0)\n                    return `L${index}: ${instrDebugValue(instr)}     # ${instr.comment}`;\n                else\n                    return `L${index}: ${instrDebugValue(instr)}`;\n            });\n        }\n        else {\n            return this.instrs.map((instr, index) => `L${index}: ${instr.debugValue}`);\n        }\n    }\n}\nexport class Instr {\n    constructor(opcode, char = null) {\n        this.opcode = opcode;\n        this.char = char;\n        this.offset = 0;\n        this.comment = \"\";\n        this.args = [];\n        this.char = char;\n    }\n    add(...args) {\n        this.args.push(...args);\n        return this;\n    }\n    get debugValue() {\n        let c = this.comment.trim();\n        if (c.length > 0)\n            c = \"    # \" + c;\n        return `${this.opcode} ${this.args.join(\" \")}    ${this.char || \"\"}   ${c}`;\n    }\n}\nexport class Thread {\n    constructor(offset = 0, gen = 0) {\n        this.offset = offset;\n        this.gen = gen;\n        this.parentId = -1;\n        this.id = 0;\n        this.priority = 0;\n        this.groups = [];\n        this.positions = [];\n        this.registers = {};\n    }\n    regIncr(regId) {\n        if (!(regId in this.registers)) {\n            throw new Error(`Register at offset ${regId} is invalid`);\n        }\n        this.registers[regId]++;\n    }\n    regAcquire(regId) {\n        if (regId in this.registers) {\n            throw new Error(`Register at offset ${regId} already acquired.  Release it first`);\n        }\n        this.registers[regId] = 0;\n    }\n    regRelease(regId) {\n        if (!(regId in this.registers)) {\n            throw new Error(`Register at offset ${regId} is invalid`);\n        }\n        delete this.registers[regId];\n    }\n    regValue(regId) {\n        if (!(regId in this.registers)) {\n            throw new Error(`Register at offset ${regId} is invalid`);\n        }\n        return this.registers[regId];\n    }\n}\nexport class VM {\n    getState() {\n        return this.currState;\n    }\n    setState(state) {\n        this.currState = state;\n    }\n    constructor(prog, start = 0, end = -1, forward = true, configs = {}) {\n        this.prog = prog;\n        this.start = start;\n        this.end = end;\n        this.forward = forward;\n        this.threadCounter = 0;\n        this.currThreads = [];\n        this.nextThreads = [];\n        this.startPos = 0;\n        this.currState = 0;\n        this.gen = 0;\n        this.genForOffset = {};\n        if (end < 0) {\n            end = prog.length - 1;\n        }\n        this.end = end;\n    }\n    savePosition(thread, pos, tapeIndex) {\n        while (thread.positions.length <= pos)\n            thread.positions.push(-1);\n        thread.positions[pos] = tapeIndex;\n    }\n    jumpBy(thread, delta = 1) {\n        return this.jumpTo(thread, thread.offset + delta);\n    }\n    jumpTo(thread, newOffset) {\n        const out = new Thread(newOffset, this.gen);\n        out.id = thread.id;\n        out.parentId = thread.parentId;\n        out.priority = thread.priority;\n        out.positions = thread.positions;\n        out.groups = thread.groups;\n        out.registers = thread.registers;\n        return out;\n    }\n    forkTo(thread, newOffset) {\n        const out = new Thread(newOffset, this.gen);\n        out.id = ++this.threadCounter;\n        out.parentId = thread.id;\n        out.priority = thread.priority;\n        out.positions = [...thread.positions];\n        out.groups = [...thread.groups];\n        out.registers = { ...thread.registers };\n        return out;\n    }\n    startGroup(thread, groupIndex, tapeIndex) {\n        const newThread = this.forkTo(thread, thread.offset + 1);\n        newThread.groups.push([groupIndex, tapeIndex]);\n        return newThread;\n    }\n    endGroup(thread, groupIndex, tapeIndex) {\n        const newThread = this.forkTo(thread, thread.offset + 1);\n        newThread.groups.push([-groupIndex, tapeIndex]);\n        return newThread;\n    }\n    addThread(thread, list, tape, delta = 0) {\n        if (thread.offset < this.start ||\n            thread.offset > this.end ||\n            this.genForOffset[thread.offset - this.start] == this.gen) {\n            return;\n        }\n        this.genForOffset[thread.offset - this.start] = this.gen;\n        const instr = this.prog.instrs[thread.offset];\n        let nextCh;\n        let lastCh;\n        let newThread;\n        const opcode = instr.opcode;\n        switch (opcode) {\n            case OpCode.Jump:\n                newThread = this.jumpTo(thread, instr.args[0]);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.Split:\n                for (let j = 0; j < instr.args.length; j++) {\n                    const newOff = instr.args[j];\n                    const newThread = j == 0 ? this.jumpTo(thread, newOff) : this.forkTo(thread, newOff);\n                    this.addThread(newThread, list, tape, delta);\n                }\n                break;\n            case OpCode.Save:\n                newThread = this.jumpTo(thread, thread.offset + 1);\n                this.savePosition(newThread, instr.args[0], tape.index + delta);\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index + delta);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.GroupStart:\n                newThread = this.startGroup(thread, instr.args[0], tape.index + delta);\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index + delta);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.GroupEnd:\n                newThread = this.endGroup(thread, instr.args[0], tape.index + delta);\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index + delta);\n                this.addThread(newThread, list, tape, delta);\n                break;\n            case OpCode.StartingChar:\n            case OpCode.MLStartingChar:\n                lastCh = this.prevCh(tape);\n                if (tape.index == 0 || (opcode == OpCode.MLStartingChar && isNewLineChar(lastCh))) {\n                    this.addThread(this.jumpBy(thread, 1), list, tape, delta);\n                }\n                break;\n            case OpCode.EndingChar:\n            case OpCode.MLEndingChar:\n                nextCh = this.nextCh(tape);\n                if (nextCh == \"\" || (opcode == OpCode.MLEndingChar && isNewLineChar(nextCh))) {\n                    this.addThread(this.jumpBy(thread, 1), list, tape, delta);\n                }\n                break;\n            case OpCode.StartOfWord:\n                break;\n            case OpCode.EndOfWord:\n                break;\n            case OpCode.RBegin:\n                {\n                    const [groupIndex, negate, end] = instr.args;\n                    const pos = (1 + groupIndex) * 2;\n                    const groupStart = thread.positions[pos];\n                    const [matchSuccess, matchEnd] = this.recurseMatch(tape, groupStart - 1, instr.offset + 1, end, false, negate == 1);\n                    if (matchSuccess) {\n                        this.addThread(this.jumpTo(thread, end + 1), list, tape, delta);\n                    }\n                }\n                break;\n            case OpCode.Begin:\n                const [consume, negate, end] = instr.args;\n                if (consume == 1) {\n                    if (this.tracer)\n                        this.tracer.threadQueued(thread, tape.index);\n                    list.push(thread);\n                }\n                else {\n                    const [matchSuccess, matchEnd] = this.recurseMatch(tape, tape.index + 1, instr.offset + 1, end, true, negate == 1);\n                    if (matchSuccess) {\n                        this.addThread(this.jumpTo(thread, end + 1), list, tape, delta);\n                    }\n                }\n                break;\n            case OpCode.EnsureState:\n                const states = instr.args;\n                for (const state of states) {\n                    if (this.currState == state) {\n                        this.addThread(this.jumpBy(thread, 1), list, tape, delta);\n                        break;\n                    }\n                }\n                break;\n            default:\n                if (this.tracer)\n                    this.tracer.threadQueued(thread, tape.index);\n                list.push(thread);\n                break;\n        }\n    }\n    matchCurrPos(tape, char, ignoreCase = false) {\n        if (ignoreCase) {\n            return char.match(tape.currChCodeLower) || char.match(tape.currChCodeUpper);\n        }\n        else {\n            return char.match(tape.currChCode);\n        }\n    }\n    hasMore(tape) {\n        return this.forward ? tape.hasMore : tape.index >= 0;\n    }\n    nextCh(tape) {\n        const next = tape.index + (this.forward ? 1 : -1);\n        return tape.charAt(next);\n    }\n    prevCh(tape) {\n        return tape.charAt(tape.index - (this.forward ? 1 : -1));\n    }\n    match(tape) {\n        if (this.end < this.start)\n            return null;\n        this.startMatching(tape);\n        let bestMatch = null;\n        while (this.currThreads.length > 0) {\n            bestMatch = this.stepChar(tape, bestMatch);\n        }\n        if (bestMatch != null)\n            tape.index = bestMatch.end;\n        return bestMatch;\n    }\n    recurseMatch(tape, tapeIndex, startOffset, endOffset, forward = true, negate = false) {\n        const savedPos = tape.index;\n        if (!tape.canAdvance(forward ? 1 : -1))\n            return [negate, -1];\n        tape.index = tapeIndex;\n        const vm = new VM(this.prog, startOffset, endOffset, forward);\n        const match = vm.match(tape);\n        const newPos = tape.index;\n        tape.index = savedPos;\n        return [(match != null && !negate) || (match == null && negate), newPos];\n    }\n    startMatching(tape) {\n        this.currThreads = [];\n        this.nextThreads = [];\n        this.gen++;\n        this.addThread(new Thread(this.start, this.gen), this.currThreads, tape);\n        this.startPos = tape.index;\n    }\n    stepChar(tape, currMatch = null) {\n        this.gen++;\n        for (let i = 0; i < this.currThreads.length; i++) {\n            const thread = this.currThreads[i];\n            const nextMatch = this.stepThread(tape, thread);\n            if (nextMatch != null) {\n                if (currMatch == null ||\n                    nextMatch.priority > currMatch.priority ||\n                    (nextMatch.priority == currMatch.priority && nextMatch.end > currMatch.end)) {\n                    currMatch = nextMatch;\n                    break;\n                }\n                else if (currMatch != nextMatch) {\n                }\n            }\n        }\n        if (this.hasMore(tape)) {\n            tape.advance(this.forward ? 1 : -1);\n        }\n        this.currThreads = this.nextThreads;\n        this.nextThreads = [];\n        return currMatch;\n    }\n    stepThread(tape, thread) {\n        if (this.tracer)\n            this.tracer.threadStepped(thread, tape.index, this.gen);\n        let currMatch = null;\n        const instrs = this.prog.instrs;\n        const instr = instrs[thread.offset];\n        const opcode = instr.opcode;\n        const args = instr.args;\n        const delta = this.forward ? 1 : -1;\n        let advanceTape = false;\n        let ch;\n        switch (opcode) {\n            case OpCode.RBegin:\n                throw new Error(\"Invalid state.  Reverse matches must be handled in addThread\");\n                break;\n            case OpCode.Begin:\n                const [consume, negate, end] = instr.args;\n                TSU.assert(consume == 1, \"Plain lookahead cannot be here\");\n                const [matchSuccess, matchEnd] = this.recurseMatch(tape, tape.index, instr.offset + 1, end, true, negate == 1);\n                if (matchSuccess) {\n                    this.addThread(this.jumpTo(thread, end + 1), this.nextThreads, tape);\n                }\n                break;\n            case OpCode.End:\n                const out = new Match(-1, -1, this.startPos, tape.index);\n                out.groups = thread.groups;\n                out.positions = thread.positions;\n                return out;\n                break;\n            case OpCode.Match:\n                if (tape.index > this.startPos) {\n                    const currPriority = instr.args[0];\n                    const matchIndex = instr.args[1];\n                    currMatch = new Match();\n                    currMatch.start = this.startPos;\n                    currMatch.end = tape.index;\n                    currMatch.priority = currPriority;\n                    currMatch.matchIndex = matchIndex;\n                    currMatch.groups = thread.groups;\n                    currMatch.positions = thread.positions;\n                }\n                break;\n            case OpCode.Char:\n            case OpCode.CIChar:\n                if (this.hasMore(tape)) {\n                    advanceTape = this.matchCurrPos(tape, instr.char, opcode == OpCode.CIChar);\n                }\n                break;\n            case OpCode.AnyNonNL:\n            case OpCode.Any:\n                if (this.hasMore(tape)) {\n                    advanceTape = opcode == OpCode.Any || !isNewLineChar(tape.currCh);\n                }\n                break;\n        }\n        if (advanceTape) {\n            this.addThread(this.jumpBy(thread, 1), this.nextThreads, tape, delta);\n        }\n        return currMatch;\n    }\n}\nexport function InstrDebugValue(instr) {\n    switch (instr.opcode) {\n        case OpCode.Match:\n            return `Match ${instr.args[0]} ${instr.args[1]}`;\n        case OpCode.Char:\n        case OpCode.CIChar: {\n            let out = `${OpCode[instr.opcode].toString()} `;\n            out += `${instr.char.debugValue()}`;\n            return out;\n        }\n        case OpCode.Any:\n            return \".\";\n        case OpCode.AnyNonNL:\n            return \"NL.\";\n        case OpCode.StartingChar:\n            return \"^\";\n        case OpCode.MLStartingChar:\n            return \"NL^\";\n        case OpCode.EndingChar:\n            return \"$NL\";\n        case OpCode.MLEndingChar:\n            return \"$NL_MultiLine\";\n        case OpCode.Save:\n            return `Save ${instr.args[0]}`;\n        case OpCode.GroupStart:\n            return `GroupStart ${instr.args[0]}`;\n        case OpCode.GroupEnd:\n            return `GroupEnd ${instr.args[0]}`;\n        case OpCode.Split:\n            return `Split ${instr.args.join(\", \")}`;\n        case OpCode.Jump:\n            return `Jump ${instr.args[0]}`;\n        case OpCode.Begin:\n            return `Begin ${instr.args.join(\" \")}`;\n        case OpCode.RBegin:\n            return `RBegin ${instr.args.join(\" \")}`;\n        case OpCode.End:\n            return `End ${instr.args.join(\" \")}`;\n        case OpCode.EnsureState:\n            return `EnsureState ${instr.args.join(\" \")}`;\n        default:\n            throw new Error(\"Invalid Opcode: \" + instr.opcode);\n    }\n}\n//# sourceMappingURL=vm.js.map","export class TokenizerError extends Error {\n    constructor(message, offset, length, type, value = null) {\n        super(message);\n        this.offset = offset;\n        this.length = length;\n        this.type = type;\n        this.value = value;\n        this.name = \"TokenizerError\";\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexport class UnexpectedTokenError extends Error {\n    constructor(foundToken, ...expectedTokens) {\n        super(`Found Token: ${foundToken?.tag || \"EOF\"} (${foundToken?.value || \"\"}), Expected: ${expectedTokens.join(\", \")}`);\n        this.foundToken = foundToken;\n        this.name = \"UnexpectedTokenError\";\n        this.expectedTokens = expectedTokens;\n    }\n}\n//# sourceMappingURL=errors.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { RegexType, CharType, } from \"./core\";\nimport { OpCode, Prog, Instr } from \"./vm\";\nexport class Compiler {\n    constructor(regexResolver, listener = null) {\n        this.regexResolver = regexResolver;\n        this.listener = listener;\n        this.emitGroups = false;\n        this.emitPosition = true;\n    }\n    compile(rules) {\n        const out = new Prog();\n        const split = rules.length <= 1 ? new Instr(OpCode.Split) : out.add(OpCode.Split, null);\n        rules.forEach((rule, i) => {\n            split.add(out.instrs.length);\n            const ignoreCase = rule.expr.ignoreCase == null ? false : rule.expr.ignoreCase;\n            const dotAll = rule.expr.dotAll == null ? true : rule.expr.dotAll;\n            const multiline = rule.expr.multiline == null ? true : rule.expr.multiline;\n            if (rule.needsSpecificStates && rule.activeStates != null) {\n                const ensureInstr = out.add(OpCode.EnsureState, null);\n                rule.activeStates.forEach((state) => {\n                    const ind = out.registerState(state);\n                    ensureInstr.add(ind);\n                });\n            }\n            this.compileExpr(rule.expr, out, ignoreCase, dotAll, multiline);\n            out.add(OpCode.Match, null).add(rule.priority, rule.matchIndex >= 0 ? rule.matchIndex : i);\n        });\n        return out;\n    }\n    compileExpr(expr, prog, ignoreCase, dotAll, multiline) {\n        const start = prog.length;\n        const currOffset = prog.length;\n        if (expr.groupIndex >= 0) {\n            if (this.emitPosition)\n                prog.add(OpCode.Save).add((1 + expr.groupIndex) * 2);\n            if (this.emitGroups)\n                prog.add(OpCode.GroupStart).add(1 + expr.groupIndex);\n        }\n        if (expr.tag == RegexType.CHAR) {\n            this.compileChar(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.START_OF_INPUT) {\n            const ml = expr.multiline == null ? multiline : expr.multiline;\n            prog.add(ml ? OpCode.MLStartingChar : OpCode.StartingChar);\n        }\n        else if (expr.tag == RegexType.END_OF_INPUT) {\n            const ml = expr.multiline == null ? multiline : expr.multiline;\n            prog.add(ml ? OpCode.MLEndingChar : OpCode.EndingChar);\n        }\n        else if (expr.tag == RegexType.START_OF_WORD) {\n            prog.add(OpCode.StartOfWord);\n        }\n        else if (expr.tag == RegexType.END_OF_WORD) {\n            prog.add(OpCode.EndOfWord);\n        }\n        else if (expr.tag == RegexType.CAT) {\n            this.compileCat(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.UNION) {\n            this.compileUnion(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.QUANT) {\n            this.compileQuant(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.VAR) {\n            this.compileVar(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.BACK_NAMED_REF) {\n            this.compileBackNamedRef(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.BACK_NUM_REF) {\n            this.compileBackNumRef(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.LOOK_AHEAD) {\n            this.compileLookAhead(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else if (expr.tag == RegexType.LOOK_BACK) {\n            this.compileLookBack(expr, prog, ignoreCase, dotAll, multiline);\n        }\n        else {\n            throw new Error(\"Regex Type not yet supported: \" + expr.tag);\n        }\n        if (expr.groupIndex >= 0) {\n            if (this.emitGroups)\n                prog.add(OpCode.GroupEnd).add(1 + expr.groupIndex);\n            if (this.emitPosition)\n                prog.add(OpCode.Save).add((1 + expr.groupIndex) * 2 + 1);\n        }\n        if (this.listener && prog.length > currOffset) {\n            this.listener(expr, prog, currOffset, prog.length - currOffset);\n        }\n        return prog.length - start;\n    }\n    compileChar(char, prog, ignoreCase, dotAll, multiline) {\n        if (char.op == CharType.AnyChar) {\n            prog.add(dotAll ? OpCode.Any : OpCode.AnyNonNL);\n        }\n        else {\n            const instr = prog.add(ignoreCase ? OpCode.CIChar : OpCode.Char);\n            instr.char = char;\n        }\n    }\n    compileCat(cat, prog, ignoreCase, dotAll, multiline) {\n        for (const child of cat.children) {\n            this.compileExpr(child, prog, ignoreCase, dotAll, multiline);\n        }\n    }\n    compileBackNumRef(ne, prog, ignoreCase, dotAll, multiline) {\n        throw new Error(\"BackNumRef Not Implemented\");\n    }\n    compileBackNamedRef(ne, prog, ignoreCase, dotAll, multiline) {\n        throw new Error(\"BackNameRef Not Implemented\");\n    }\n    compileVar(v, prog, ignoreCase, dotAll, multiline) {\n        const name = v.name.trim();\n        const expr = this.regexResolver ? this.regexResolver(name) : null;\n        if (expr == null) {\n            throw new Error(`Cannot find expression: ${name}`);\n        }\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n    }\n    compileUnion(union, prog, ignoreCase, dotAll, multiline) {\n        const split = prog.add(OpCode.Split);\n        const jumps = [];\n        for (let i = 0; i < union.options.length; i++) {\n            split.add(prog.length);\n            this.compileExpr(union.options[i], prog, ignoreCase, dotAll, multiline);\n            if (i < union.options.length - 1) {\n                jumps.push(prog.add(OpCode.Jump));\n            }\n        }\n        for (const jmp of jumps) {\n            jmp.add(prog.length);\n        }\n    }\n    compileQuant(quant, prog, ignoreCase, dotAll, multiline) {\n        if (quant.minCount == 0 && quant.maxCount == TSU.Constants.MAX_INT) {\n            this.compileAtleast0(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n        }\n        else if (quant.minCount == 1 && quant.maxCount == TSU.Constants.MAX_INT) {\n            this.compileAtleast1(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n        }\n        else if (quant.minCount == 0 && quant.maxCount == 1) {\n            this.compileOptional(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n        }\n        else {\n            for (let i = 0; i < quant.minCount; i++) {\n                this.compileExpr(quant.expr, prog, ignoreCase, dotAll, multiline);\n            }\n            if (quant.isUnlimited) {\n                this.compileAtleast0(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n            }\n            else {\n                for (let i = quant.minCount; i < quant.maxCount; i++) {\n                    this.compileOptional(quant.expr, prog, quant.greedy, ignoreCase, dotAll, multiline);\n                }\n            }\n        }\n    }\n    compileAtleast1(expr, prog, greedy = true, ignoreCase, dotAll, multiline) {\n        const l1 = prog.length;\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n        const split = prog.add(OpCode.Split);\n        const l3 = prog.length;\n        if (greedy) {\n            split.add(l1, l3);\n        }\n        else {\n            split.add(l3, l1);\n        }\n    }\n    compileAtleast0(expr, prog, greedy, ignoreCase, dotAll, multiline) {\n        const split = prog.add(OpCode.Split);\n        const l1 = split.offset;\n        const l2 = prog.length;\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n        prog.add(OpCode.Jump).add(l1);\n        const l3 = prog.length;\n        if (greedy) {\n            split.add(l2, l3);\n        }\n        else {\n            split.add(l3, l2);\n        }\n    }\n    compileOptional(expr, prog, greedy, ignoreCase, dotAll, multiline) {\n        const split = prog.add(OpCode.Split);\n        const l1 = prog.length;\n        this.compileExpr(expr, prog, ignoreCase, dotAll, multiline);\n        const l2 = prog.length;\n        if (greedy) {\n            split.add(l1, l2);\n        }\n        else {\n            split.add(l2, l1);\n        }\n    }\n    compileLookAhead(la, prog, ignoreCase, dotAll, multiline) {\n        this.compileExpr(la.expr, prog, ignoreCase, dotAll, multiline);\n        const begin = prog.add(OpCode.Begin).add(0, la.negate ? 1 : 0);\n        this.compileExpr(la.cond, prog, ignoreCase, dotAll, multiline);\n        const end = prog.add(OpCode.End).add(begin.offset);\n        begin.add(end.offset);\n    }\n    compileLookBack(lb, prog, ignoreCase, dotAll, multiline) {\n        this.compileExpr(lb.expr, prog, ignoreCase, dotAll, multiline);\n        TSU.assert(lb.expr.groupIndex >= 0, \"LookBack Assertion requires expression to have a group Index\");\n        const begin = prog.add(OpCode.RBegin).add(lb.expr.groupIndex, lb.negate ? 1 : 0);\n        this.compileExpr(lb.cond.reverse(), prog, ignoreCase, dotAll, multiline);\n        const end = prog.add(OpCode.End).add(begin.offset);\n        begin.add(end.offset);\n    }\n}\n//# sourceMappingURL=compiler.js.map","import { Tape, TapeHelper } from \"./tape\";\nimport { Token } from \"./token\";\nimport { TokenizerError } from \"./errors\";\nexport class SimpleTokenizer {\n    constructor(tape) {\n        this.peekedToken = null;\n        this.literals = [];\n        this.matchers = [];\n        if (typeof tape === \"string\") {\n            tape = new Tape(tape);\n        }\n        this.tape = tape;\n    }\n    addMatcher(matcher, skip = false) {\n        this.matchers.push([matcher, skip]);\n        return this;\n    }\n    addLiteral(lit, tokType) {\n        const index = this.literals.findIndex((k) => k[0] == lit);\n        if (index < 0) {\n            this.literals.push([lit, tokType]);\n            return this.literals.length - 1;\n        }\n        else {\n            if (this.literals[index][1] != tokType) {\n                throw new Error(`Literal '${lit}' already registered as ${tokType}`);\n            }\n            return index;\n        }\n    }\n    nextToken() {\n        if (!this.tape.hasMore)\n            return null;\n        const pos = this.tape.index;\n        for (let i = 0; i < this.literals.length; i++) {\n            const [kwd, toktype] = this.literals[i];\n            if (TapeHelper.matches(this.tape, kwd)) {\n                const out = new Token(toktype, i, pos, this.tape.index);\n                out.value = kwd;\n                return out;\n            }\n        }\n        for (let i = 0; i < this.matchers.length; i++) {\n            const [matcher, skip] = this.matchers[i];\n            const token = matcher(this.tape, pos);\n            if (token != null) {\n                if (skip) {\n                    return this.nextToken();\n                }\n                else {\n                    token.start = pos;\n                    token.end = this.tape.index;\n                    return token;\n                }\n            }\n        }\n        throw new TokenizerError(\"Invalid Character\", this.tape.index, 1, \"InvalidCharacter\", this.tape.currCh);\n    }\n}\n//# sourceMappingURL=helpers.js.map","export var PropertyName;\n(function (PropertyName) {\n    PropertyName[PropertyName[\"gc\"] = 0] = \"gc\";\n    PropertyName[PropertyName[\"General_Category\"] = 0] = \"General_Category\";\n    PropertyName[PropertyName[\"sc\"] = 1] = \"sc\";\n    PropertyName[PropertyName[\"Script\"] = 1] = \"Script\";\n    PropertyName[PropertyName[\"scx\"] = 2] = \"scx\";\n    PropertyName[PropertyName[\"Script_Extension\"] = 2] = \"Script_Extension\";\n    PropertyName[PropertyName[\"Any\"] = 3] = \"Any\";\n    PropertyName[PropertyName[\"ASCII\"] = 4] = \"ASCII\";\n    PropertyName[PropertyName[\"AHex\"] = 5] = \"AHex\";\n    PropertyName[PropertyName[\"ASCII_Hex_Digit\"] = 5] = \"ASCII_Hex_Digit\";\n    PropertyName[PropertyName[\"Alpha\"] = 6] = \"Alpha\";\n    PropertyName[PropertyName[\"Alphabetic\"] = 6] = \"Alphabetic\";\n    PropertyName[PropertyName[\"Bidi_M\"] = 7] = \"Bidi_M\";\n    PropertyName[PropertyName[\"Bidi_Mirrored\"] = 7] = \"Bidi_Mirrored\";\n    PropertyName[PropertyName[\"Bidi_C\"] = 8] = \"Bidi_C\";\n    PropertyName[PropertyName[\"Bidi_Control\"] = 8] = \"Bidi_Control\";\n    PropertyName[PropertyName[\"CI\"] = 9] = \"CI\";\n    PropertyName[PropertyName[\"Case_Ignorable\"] = 9] = \"Case_Ignorable\";\n    PropertyName[PropertyName[\"Cased\"] = 10] = \"Cased\";\n    PropertyName[PropertyName[\"CWCF\"] = 11] = \"CWCF\";\n    PropertyName[PropertyName[\"Changes_When_Casefolded\"] = 11] = \"Changes_When_Casefolded\";\n    PropertyName[PropertyName[\"CWCM\"] = 12] = \"CWCM\";\n    PropertyName[PropertyName[\"Changes_When_Casemapped\"] = 12] = \"Changes_When_Casemapped\";\n    PropertyName[PropertyName[\"CWL\"] = 13] = \"CWL\";\n    PropertyName[PropertyName[\"Changes_When_Lowercased\"] = 13] = \"Changes_When_Lowercased\";\n    PropertyName[PropertyName[\"CWKCF\"] = 14] = \"CWKCF\";\n    PropertyName[PropertyName[\"Changes_When_NFKC_Casefolded\"] = 14] = \"Changes_When_NFKC_Casefolded\";\n    PropertyName[PropertyName[\"CWT\"] = 15] = \"CWT\";\n    PropertyName[PropertyName[\"Changes_When_Titlecased\"] = 15] = \"Changes_When_Titlecased\";\n    PropertyName[PropertyName[\"CWU\"] = 16] = \"CWU\";\n    PropertyName[PropertyName[\"Changes_When_Uppercased\"] = 16] = \"Changes_When_Uppercased\";\n    PropertyName[PropertyName[\"Dash\"] = 17] = \"Dash\";\n    PropertyName[PropertyName[\"DI\"] = 18] = \"DI\";\n    PropertyName[PropertyName[\"Default_Ignorable_Code_Point\"] = 18] = \"Default_Ignorable_Code_Point\";\n    PropertyName[PropertyName[\"Dep\"] = 19] = \"Dep\";\n    PropertyName[PropertyName[\"Deprecated\"] = 19] = \"Deprecated\";\n    PropertyName[PropertyName[\"Dia\"] = 20] = \"Dia\";\n    PropertyName[PropertyName[\"Diacritic\"] = 20] = \"Diacritic\";\n    PropertyName[PropertyName[\"Emoji\"] = 21] = \"Emoji\";\n    PropertyName[PropertyName[\"Emoji_Component\"] = 22] = \"Emoji_Component\";\n    PropertyName[PropertyName[\"Emoji_Modifier\"] = 23] = \"Emoji_Modifier\";\n    PropertyName[PropertyName[\"Emoji_Modifier_Base\"] = 24] = \"Emoji_Modifier_Base\";\n    PropertyName[PropertyName[\"Emoji_Presentation\"] = 25] = \"Emoji_Presentation\";\n    PropertyName[PropertyName[\"Ext\"] = 26] = \"Ext\";\n    PropertyName[PropertyName[\"Extender\"] = 26] = \"Extender\";\n    PropertyName[PropertyName[\"Gr_Base\"] = 27] = \"Gr_Base\";\n    PropertyName[PropertyName[\"Grapheme_Base\"] = 27] = \"Grapheme_Base\";\n    PropertyName[PropertyName[\"Gr_Ext\"] = 28] = \"Gr_Ext\";\n    PropertyName[PropertyName[\"Grapheme_Extend\"] = 28] = \"Grapheme_Extend\";\n    PropertyName[PropertyName[\"Hex\"] = 29] = \"Hex\";\n    PropertyName[PropertyName[\"Hex_Digit\"] = 29] = \"Hex_Digit\";\n    PropertyName[PropertyName[\"IDSB\"] = 30] = \"IDSB\";\n    PropertyName[PropertyName[\"IDS_Binary_Operator\"] = 30] = \"IDS_Binary_Operator\";\n    PropertyName[PropertyName[\"IDST\"] = 31] = \"IDST\";\n    PropertyName[PropertyName[\"IDS_Trinary_Operator\"] = 31] = \"IDS_Trinary_Operator\";\n    PropertyName[PropertyName[\"IDC\"] = 32] = \"IDC\";\n    PropertyName[PropertyName[\"ID_Continue\"] = 32] = \"ID_Continue\";\n    PropertyName[PropertyName[\"IDS\"] = 33] = \"IDS\";\n    PropertyName[PropertyName[\"ID_Start\"] = 33] = \"ID_Start\";\n    PropertyName[PropertyName[\"Ideo\"] = 34] = \"Ideo\";\n    PropertyName[PropertyName[\"Ideographic\"] = 34] = \"Ideographic\";\n    PropertyName[PropertyName[\"Join_C\"] = 35] = \"Join_C\";\n    PropertyName[PropertyName[\"Join_Control\"] = 35] = \"Join_Control\";\n    PropertyName[PropertyName[\"LOE\"] = 36] = \"LOE\";\n    PropertyName[PropertyName[\"Logical_Order_Exception\"] = 36] = \"Logical_Order_Exception\";\n    PropertyName[PropertyName[\"Lower\"] = 37] = \"Lower\";\n    PropertyName[PropertyName[\"Lowercase\"] = 37] = \"Lowercase\";\n    PropertyName[PropertyName[\"Math\"] = 38] = \"Math\";\n    PropertyName[PropertyName[\"NChar\"] = 39] = \"NChar\";\n    PropertyName[PropertyName[\"Noncharacter_Code_Point\"] = 39] = \"Noncharacter_Code_Point\";\n    PropertyName[PropertyName[\"Pat_Syn\"] = 40] = \"Pat_Syn\";\n    PropertyName[PropertyName[\"Pattern_Syntax\"] = 40] = \"Pattern_Syntax\";\n    PropertyName[PropertyName[\"Pat_WS\"] = 41] = \"Pat_WS\";\n    PropertyName[PropertyName[\"Pattern_White_Space\"] = 41] = \"Pattern_White_Space\";\n    PropertyName[PropertyName[\"QMark\"] = 42] = \"QMark\";\n    PropertyName[PropertyName[\"Quotation_Mark\"] = 42] = \"Quotation_Mark\";\n    PropertyName[PropertyName[\"Radical\"] = 43] = \"Radical\";\n    PropertyName[PropertyName[\"RI\"] = 44] = \"RI\";\n    PropertyName[PropertyName[\"Regional_Indicator\"] = 44] = \"Regional_Indicator\";\n    PropertyName[PropertyName[\"STerm\"] = 45] = \"STerm\";\n    PropertyName[PropertyName[\"Sentence_Terminal\"] = 45] = \"Sentence_Terminal\";\n    PropertyName[PropertyName[\"SD\"] = 46] = \"SD\";\n    PropertyName[PropertyName[\"Soft_Dotted\"] = 46] = \"Soft_Dotted\";\n    PropertyName[PropertyName[\"Term\"] = 47] = \"Term\";\n    PropertyName[PropertyName[\"Terminal_Punctuation\"] = 47] = \"Terminal_Punctuation\";\n    PropertyName[PropertyName[\"UIdeo\"] = 48] = \"UIdeo\";\n    PropertyName[PropertyName[\"Unified_Ideograph\"] = 48] = \"Unified_Ideograph\";\n    PropertyName[PropertyName[\"Upper\"] = 49] = \"Upper\";\n    PropertyName[PropertyName[\"Uppercase\"] = 49] = \"Uppercase\";\n    PropertyName[PropertyName[\"VS\"] = 50] = \"VS\";\n    PropertyName[PropertyName[\"Variation_Selector\"] = 50] = \"Variation_Selector\";\n    PropertyName[PropertyName[\"space\"] = 51] = \"space\";\n    PropertyName[PropertyName[\"White_Space\"] = 51] = \"White_Space\";\n    PropertyName[PropertyName[\"XIDC\"] = 52] = \"XIDC\";\n    PropertyName[PropertyName[\"XID_Continue\"] = 52] = \"XID_Continue\";\n    PropertyName[PropertyName[\"XIDS\"] = 53] = \"XIDS\";\n    PropertyName[PropertyName[\"XID_Start\"] = 53] = \"XID_Start\";\n})(PropertyName || (PropertyName = {}));\nexport var PropertyValue;\n(function (PropertyValue) {\n    PropertyValue[PropertyValue[\"LC\"] = 0] = \"LC\";\n    PropertyValue[PropertyValue[\"Cased_Letter\"] = 0] = \"Cased_Letter\";\n    PropertyValue[PropertyValue[\"Pe\"] = 1] = \"Pe\";\n    PropertyValue[PropertyValue[\"Close_Punctuation\"] = 1] = \"Close_Punctuation\";\n    PropertyValue[PropertyValue[\"Pc\"] = 2] = \"Pc\";\n    PropertyValue[PropertyValue[\"Connector_Punctuation\"] = 2] = \"Connector_Punctuation\";\n    PropertyValue[PropertyValue[\"Cc\"] = 3] = \"Cc\";\n    PropertyValue[PropertyValue[\"cntrl\"] = 3] = \"cntrl\";\n    PropertyValue[PropertyValue[\"Control\"] = 3] = \"Control\";\n    PropertyValue[PropertyValue[\"Sc\"] = 4] = \"Sc\";\n    PropertyValue[PropertyValue[\"Currency_Symbol\"] = 4] = \"Currency_Symbol\";\n    PropertyValue[PropertyValue[\"Pd\"] = 5] = \"Pd\";\n    PropertyValue[PropertyValue[\"Dash_Punctuation\"] = 5] = \"Dash_Punctuation\";\n    PropertyValue[PropertyValue[\"Nd\"] = 6] = \"Nd\";\n    PropertyValue[PropertyValue[\"digit\"] = 6] = \"digit\";\n    PropertyValue[PropertyValue[\"Decimal_Number\"] = 6] = \"Decimal_Number\";\n    PropertyValue[PropertyValue[\"Me\"] = 7] = \"Me\";\n    PropertyValue[PropertyValue[\"Enclosing_Mark\"] = 7] = \"Enclosing_Mark\";\n    PropertyValue[PropertyValue[\"Pf\"] = 8] = \"Pf\";\n    PropertyValue[PropertyValue[\"Final_Punctuation\"] = 8] = \"Final_Punctuation\";\n    PropertyValue[PropertyValue[\"Cf\"] = 9] = \"Cf\";\n    PropertyValue[PropertyValue[\"Format\"] = 9] = \"Format\";\n    PropertyValue[PropertyValue[\"Pi\"] = 10] = \"Pi\";\n    PropertyValue[PropertyValue[\"Initial_Punctuation\"] = 10] = \"Initial_Punctuation\";\n    PropertyValue[PropertyValue[\"L\"] = 11] = \"L\";\n    PropertyValue[PropertyValue[\"Letter\"] = 11] = \"Letter\";\n    PropertyValue[PropertyValue[\"Nl\"] = 12] = \"Nl\";\n    PropertyValue[PropertyValue[\"Letter_Number\"] = 12] = \"Letter_Number\";\n    PropertyValue[PropertyValue[\"Zl\"] = 13] = \"Zl\";\n    PropertyValue[PropertyValue[\"Line_Separator\"] = 13] = \"Line_Separator\";\n    PropertyValue[PropertyValue[\"Ll\"] = 14] = \"Ll\";\n    PropertyValue[PropertyValue[\"Lowercase_Letter\"] = 14] = \"Lowercase_Letter\";\n    PropertyValue[PropertyValue[\"M\"] = 15] = \"M\";\n    PropertyValue[PropertyValue[\"Combining_Mark\"] = 15] = \"Combining_Mark\";\n    PropertyValue[PropertyValue[\"Mark\"] = 16] = \"Mark\";\n    PropertyValue[PropertyValue[\"Sm\"] = 17] = \"Sm\";\n    PropertyValue[PropertyValue[\"Math_Symbol\"] = 17] = \"Math_Symbol\";\n    PropertyValue[PropertyValue[\"Lm\"] = 18] = \"Lm\";\n    PropertyValue[PropertyValue[\"Modifier_Letter\"] = 18] = \"Modifier_Letter\";\n    PropertyValue[PropertyValue[\"Sk\"] = 19] = \"Sk\";\n    PropertyValue[PropertyValue[\"Modifier_Symbol\"] = 19] = \"Modifier_Symbol\";\n    PropertyValue[PropertyValue[\"Mn\"] = 20] = \"Mn\";\n    PropertyValue[PropertyValue[\"Nonspacing_Mark\"] = 20] = \"Nonspacing_Mark\";\n    PropertyValue[PropertyValue[\"N\"] = 21] = \"N\";\n    PropertyValue[PropertyValue[\"Number\"] = 21] = \"Number\";\n    PropertyValue[PropertyValue[\"Ps\"] = 22] = \"Ps\";\n    PropertyValue[PropertyValue[\"Open_Punctuation\"] = 22] = \"Open_Punctuation\";\n    PropertyValue[PropertyValue[\"C\"] = 23] = \"C\";\n    PropertyValue[PropertyValue[\"Other\"] = 23] = \"Other\";\n    PropertyValue[PropertyValue[\"Lo\"] = 24] = \"Lo\";\n    PropertyValue[PropertyValue[\"Other_Letter\"] = 24] = \"Other_Letter\";\n    PropertyValue[PropertyValue[\"No\"] = 25] = \"No\";\n    PropertyValue[PropertyValue[\"Other_Number\"] = 25] = \"Other_Number\";\n    PropertyValue[PropertyValue[\"Po\"] = 26] = \"Po\";\n    PropertyValue[PropertyValue[\"Other_Punctuation\"] = 26] = \"Other_Punctuation\";\n    PropertyValue[PropertyValue[\"So\"] = 27] = \"So\";\n    PropertyValue[PropertyValue[\"Other_Symbol\"] = 27] = \"Other_Symbol\";\n    PropertyValue[PropertyValue[\"Zp\"] = 28] = \"Zp\";\n    PropertyValue[PropertyValue[\"Paragraph_Separator\"] = 28] = \"Paragraph_Separator\";\n    PropertyValue[PropertyValue[\"Co\"] = 29] = \"Co\";\n    PropertyValue[PropertyValue[\"Private_Use\"] = 29] = \"Private_Use\";\n    PropertyValue[PropertyValue[\"P\"] = 30] = \"P\";\n    PropertyValue[PropertyValue[\"punct\"] = 30] = \"punct\";\n    PropertyValue[PropertyValue[\"Punctuation\"] = 30] = \"Punctuation\";\n    PropertyValue[PropertyValue[\"Z\"] = 31] = \"Z\";\n    PropertyValue[PropertyValue[\"Separator\"] = 31] = \"Separator\";\n    PropertyValue[PropertyValue[\"Zs\"] = 32] = \"Zs\";\n    PropertyValue[PropertyValue[\"Space_Separator\"] = 32] = \"Space_Separator\";\n    PropertyValue[PropertyValue[\"Mc\"] = 33] = \"Mc\";\n    PropertyValue[PropertyValue[\"Spacing_Mark\"] = 33] = \"Spacing_Mark\";\n    PropertyValue[PropertyValue[\"Cs\"] = 34] = \"Cs\";\n    PropertyValue[PropertyValue[\"Surrogate\"] = 34] = \"Surrogate\";\n    PropertyValue[PropertyValue[\"S\"] = 35] = \"S\";\n    PropertyValue[PropertyValue[\"Symbol\"] = 35] = \"Symbol\";\n    PropertyValue[PropertyValue[\"Lt\"] = 36] = \"Lt\";\n    PropertyValue[PropertyValue[\"Titlecase_Letter\"] = 36] = \"Titlecase_Letter\";\n    PropertyValue[PropertyValue[\"Cn\"] = 37] = \"Cn\";\n    PropertyValue[PropertyValue[\"Unassigned\"] = 37] = \"Unassigned\";\n    PropertyValue[PropertyValue[\"Lu\"] = 38] = \"Lu\";\n    PropertyValue[PropertyValue[\"Uppercase_Letter\"] = 38] = \"Uppercase_Letter\";\n})(PropertyValue || (PropertyValue = {}));\nexport function propertyNameFor(value) {\n    value = value.trim();\n    if (!(value in PropertyName)) {\n        throw new SyntaxError(\"Invalid property name: \" + value);\n    }\n    return PropertyName[value];\n}\nexport function propertyValueFor(value) {\n    value = value.trim();\n    if (!(value in PropertyValue)) {\n        throw new SyntaxError(\"Invalid property value: \" + value);\n    }\n    return PropertyValue[value];\n}\nexport function propertyNameString(value) {\n    if (!(value in PropertyName)) {\n        throw new Error(\"Invalid property name: \" + value);\n    }\n    return PropertyName[value];\n}\nexport function propertyValueString(value) {\n    if (!(value in PropertyValue)) {\n        throw new Error(\"Invalid property value: \" + value);\n    }\n    return PropertyValue[value];\n}\n//# sourceMappingURL=propertyescapes.js.map","export class TapeInterface {\n    constructor(forward = true) {\n        this.forward = forward;\n        this.index = 0;\n    }\n    advance(delta = 1) {\n        const next = this.forward ? this.index + delta : this.index - delta;\n        this.index = next;\n        return true;\n    }\n    canAdvance(delta = 1) {\n        const next = this.forward ? this.index + delta : this.index - delta;\n        return this.hasIndex(next);\n    }\n    get hasMore() {\n        const next = this.forward ? this.index : this.index - 1;\n        return this.hasIndex(next);\n    }\n    get currCh() {\n        return this.charAt(this.index);\n    }\n    get prevCh() {\n        return this.charAt(this.index - (this.forward ? 1 : -1));\n    }\n    get nextCh() {\n        const next = this.index + (this.forward ? 1 : -1);\n        return this.charAt(next);\n    }\n    get currChCode() {\n        if (!this.hasMore)\n            return -1;\n        return this.currCh.charCodeAt(0);\n    }\n    get currChCodeLower() {\n        if (!this.hasMore)\n            return -1;\n        return this.currCh.toLowerCase().charCodeAt(0);\n    }\n    get currChCodeUpper() {\n        if (!this.hasMore)\n            return -1;\n        return this.currCh.toUpperCase().charCodeAt(0);\n    }\n    charCodeAt(index) {\n        if (!this.hasIndex(index))\n            return -1;\n        return this.charAt(index).charCodeAt(0);\n    }\n    charCodeAtLower(index) {\n        if (!this.hasIndex(index))\n            return -1;\n        return this.charAt(index).toLowerCase().charCodeAt(0);\n    }\n    charCodeAtUpper(index) {\n        if (!this.hasIndex(index))\n            return -1;\n        return this.charAt(index).toUpperCase().charCodeAt(0);\n    }\n}\nexport class Tape extends TapeInterface {\n    constructor(input, forward = true) {\n        super(forward);\n        this.forward = forward;\n        this._rawInput = input;\n        this.input = [...input];\n    }\n    push(content) {\n        this._rawInput += content;\n        this.input.push(...content);\n    }\n    substring(startIndex, endIndex) {\n        return this._rawInput.substring(startIndex, endIndex);\n    }\n    hasIndex(index) {\n        return index >= 0 && index < this.input.length;\n    }\n    charAt(index) {\n        if (index < 0 || index >= this.input.length)\n            return \"\";\n        return this.input[index];\n    }\n}\nexport class TapeHelper {\n    static advanceAfter(tape, pattern, ensureNoPrefixSlash = true) {\n        let pos = TapeHelper.advanceTo(tape, pattern, ensureNoPrefixSlash);\n        if (pos >= 0) {\n            pos += pattern.length;\n            tape.index = pos;\n        }\n        return pos;\n    }\n    static advanceTo(tape, pattern, ensureNoPrefixSlash = true) {\n        const lastIndex = tape.index;\n        while (tape.hasMore) {\n            const currStart = tape.index;\n            if (TapeHelper.matches(tape, pattern)) {\n                const endIndex = tape.index;\n                tape.index = currStart;\n                let numSlashes = 0;\n                if (ensureNoPrefixSlash) {\n                    for (let i = endIndex - 1; i >= 0; i--) {\n                        if (tape.charAt(i) == \"\\\\\")\n                            numSlashes++;\n                        else\n                            break;\n                    }\n                }\n                if (numSlashes % 2 == 0) {\n                    return tape.index;\n                }\n            }\n            tape.advance(1);\n        }\n        tape.index = lastIndex;\n        throw new Error(`Unexpected end of input before (${pattern})`);\n        return -1;\n    }\n    static matches(tape, prefix, advance = true) {\n        const lastIndex = tape.index;\n        let i = 0;\n        let success = true;\n        for (; i < prefix.length; i++) {\n            if (prefix[i] != tape.currCh) {\n                success = false;\n                break;\n            }\n            tape.advance(1);\n        }\n        if (!advance || !success) {\n            tape.index = lastIndex;\n        }\n        return success;\n    }\n}\n//# sourceMappingURL=tape.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { CharClassHelpers } from \"./charclasses\";\nimport * as PropertyEscapes from \"./propertyescapes\";\nexport var RegexType;\n(function (RegexType) {\n    RegexType[RegexType[\"START_OF_INPUT\"] = 0] = \"START_OF_INPUT\";\n    RegexType[RegexType[\"END_OF_INPUT\"] = 1] = \"END_OF_INPUT\";\n    RegexType[RegexType[\"START_OF_WORD\"] = 2] = \"START_OF_WORD\";\n    RegexType[RegexType[\"END_OF_WORD\"] = 3] = \"END_OF_WORD\";\n    RegexType[RegexType[\"UNION\"] = 4] = \"UNION\";\n    RegexType[RegexType[\"CAT\"] = 5] = \"CAT\";\n    RegexType[RegexType[\"VAR\"] = 6] = \"VAR\";\n    RegexType[RegexType[\"BACK_NAMED_REF\"] = 7] = \"BACK_NAMED_REF\";\n    RegexType[RegexType[\"BACK_NUM_REF\"] = 8] = \"BACK_NUM_REF\";\n    RegexType[RegexType[\"QUANT\"] = 9] = \"QUANT\";\n    RegexType[RegexType[\"LOOK_AHEAD\"] = 10] = \"LOOK_AHEAD\";\n    RegexType[RegexType[\"LOOK_BACK\"] = 11] = \"LOOK_BACK\";\n    RegexType[RegexType[\"CHAR\"] = 12] = \"CHAR\";\n})(RegexType || (RegexType = {}));\nfunction stringRep(ch) {\n    return String.fromCharCode(ch)\n        .replace(\"\\n\", \"\\\\n\")\n        .replace(\"\\0\", \"\\\\0\")\n        .replace(\"\\r\", \"\\\\r\")\n        .replace(\"\\t\", \"\\\\t\")\n        .replace(\"\\f\", \"\\\\f\")\n        .replace(\"\\b\", \"\\\\b\");\n}\nexport class Regex {\n    constructor() {\n        this.parent = null;\n        this.reString = null;\n        this.groupIndex = -1;\n        this.groupName = null;\n        this.groupIsSilent = false;\n        this.ignoreCase = null;\n        this.dotAll = null;\n        this.multiline = null;\n    }\n    setOptions(options) {\n        if (\"dotAll\" in options)\n            this.dotAll = options.dotAll;\n        if (\"ignoreCase\" in options)\n            this.ignoreCase = options.ignoreCase;\n        if (\"groupIndex\" in options)\n            this.groupIndex = options.groupIndex;\n        if (\"multiline\" in options)\n            this.multiline = options.multiline;\n        return this;\n    }\n    debugValue() {\n        const out = {};\n        if (this.dotAll)\n            out.dotAll = true;\n        if (this.ignoreCase)\n            out.ignoreCase = true;\n        if (this.multiline)\n            out.multiline = true;\n        if (this.groupIndex >= 0)\n            out.groupIndex = this.groupIndex;\n        return out;\n    }\n    get isVariable() {\n        return false;\n    }\n    get toString() {\n        if (this.reString == null) {\n            this.reString = this.evalREString();\n        }\n        return this.reString;\n    }\n    get modifiers() {\n        let mod = \"\";\n        if (this.dotAll)\n            mod += \"d\";\n        if (this.ignoreCase)\n            mod += \"i\";\n        if (this.multiline)\n            mod += \"m\";\n        if (this.groupIndex >= 0)\n            mod += \"g:\" + this.groupIndex;\n        return mod.length == 0 ? mod : \"<\" + mod + \">\";\n    }\n}\nexport class StartOfInput extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.START_OF_INPUT;\n    }\n    debugValue() {\n        return \"^\";\n    }\n    reverse() {\n        return this;\n    }\n    evalREString() {\n        return \"^\";\n    }\n}\nexport class EndOfInput extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.END_OF_INPUT;\n    }\n    debugValue() {\n        return \"$\";\n    }\n    evalREString() {\n        return \"$\";\n    }\n    reverse() {\n        return this;\n    }\n}\nexport class StartOfWord extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.START_OF_WORD;\n    }\n    debugValue() {\n        return \"\\\\b\";\n    }\n    reverse() {\n        return this;\n    }\n    evalREString() {\n        return \"\\\\b\";\n    }\n}\nexport class EndOfWord extends Regex {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.END_OF_WORD;\n    }\n    debugValue() {\n        return \"\\\\b\";\n    }\n    reverse() {\n        return this;\n    }\n    evalREString() {\n        return \"\\\\b\";\n    }\n}\nclass Assertion extends Regex {\n    constructor(expr, cond, negate = false) {\n        super();\n        this.expr = expr;\n        this.cond = cond;\n        this.negate = negate;\n    }\n}\nexport class LookAhead extends Assertion {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.LOOK_AHEAD;\n    }\n    evalREString() {\n        return `${this.expr.toString}(?${this.negate ? \"!\" : \"=\"}${this.cond.toString})`;\n    }\n    debugValue() {\n        return [\n            \"LookAhead\",\n            {\n                ...super.debugValue(),\n                negate: this.negate,\n                expr: this.expr.debugValue(),\n                cond: this.cond.debugValue(),\n            },\n        ];\n    }\n    reverse() {\n        return new LookBack(this.expr.reverse(), this.cond.reverse(), this.negate);\n    }\n}\nexport class LookBack extends Assertion {\n    constructor() {\n        super(...arguments);\n        this.tag = RegexType.LOOK_BACK;\n    }\n    evalREString() {\n        return `(?<${this.negate ? \"!\" : \"=\"}${this.cond.toString})${this.expr.toString}`;\n    }\n    debugValue() {\n        return [\n            \"LookBack\",\n            {\n                ...super.debugValue(),\n                negate: this.negate,\n                expr: this.expr.debugValue(),\n                cond: this.cond.debugValue(),\n            },\n        ];\n    }\n    reverse() {\n        return new LookAhead(this.expr.reverse(), this.cond.reverse(), this.negate);\n    }\n}\nexport class Quant extends Regex {\n    constructor(expr, minCount = 1, maxCount = 1, greedy = true) {\n        super();\n        this.expr = expr;\n        this.minCount = minCount;\n        this.maxCount = maxCount;\n        this.greedy = greedy;\n        this.tag = RegexType.QUANT;\n    }\n    get isUnlimited() {\n        return this.maxCount < 0 || this.maxCount == TSU.Constants.MAX_INT;\n    }\n    get isVariable() {\n        return this.minCount != this.maxCount || !this.expr.isVariable;\n    }\n    reverse() {\n        return new Quant(this.expr.reverse(), this.minCount, this.maxCount, this.greedy);\n    }\n    evalREString() {\n        let quant = \"*\";\n        if (this.minCount == 1 && this.isUnlimited)\n            quant = \"+\";\n        else if (this.minCount == 0 && this.isUnlimited)\n            quant = \"*\";\n        else if (this.minCount == 0 && this.maxCount == 1)\n            quant = \"?\";\n        else if (this.minCount != 1 || this.maxCount != 1) {\n            if (this.minCount == this.maxCount) {\n                quant = `{${this.minCount}}`;\n            }\n            else {\n                quant = `{${this.minCount},${this.isUnlimited ? \"\" : this.maxCount}}`;\n            }\n        }\n        return `${this.expr.toString}${quant}`;\n    }\n    debugValue() {\n        let quant = \"*\";\n        if (this.minCount == 1 && this.isUnlimited)\n            quant = this.greedy ? \"+?\" : \"+\";\n        else if (this.minCount == 0 && this.isUnlimited)\n            quant = this.greedy ? \"*?\" : \"*\";\n        else if (this.minCount == 0 && this.maxCount == 1)\n            quant = this.greedy ? \"??\" : \"?\";\n        else if (this.minCount != 1 || this.maxCount != 1) {\n            if (this.minCount == this.maxCount) {\n                quant = `{${this.minCount}}` + (this.greedy ? \"?\" : \"\");\n            }\n            else {\n                quant = `{${this.minCount},${this.maxCount}}` + (this.greedy ? \"?\" : \"\");\n            }\n        }\n        return [quant, super.debugValue(), this.expr.debugValue()];\n    }\n}\nexport class Cat extends Regex {\n    constructor(...children) {\n        super();\n        this.tag = RegexType.CAT;\n        this.children = [];\n        for (const child of children) {\n            this.add(child);\n        }\n    }\n    get isVariable() {\n        for (const child of this.children) {\n            if (child.isVariable)\n                return true;\n        }\n        return false;\n    }\n    evalREString() {\n        const out = this.children.map((c) => c.toString).join(\"\");\n        return this.children.length > 1 ? \"(\" + out + \")\" : out;\n    }\n    reverse() {\n        const out = this.children.map((c) => c.reverse());\n        out.reverse();\n        return new Cat(...out);\n    }\n    add(child) {\n        if (child.tag != RegexType.CAT || child.groupIndex >= 0) {\n            this.children.push(child);\n        }\n        else {\n            for (const opt of child.children) {\n                this.add(opt);\n            }\n        }\n        return this;\n    }\n    debugValue() {\n        return [\"Cat\", { ...super.debugValue() }, this.children.map((c) => c.debugValue())];\n    }\n}\nexport class Union extends Regex {\n    constructor(...options) {\n        super();\n        this.tag = RegexType.UNION;\n        this.options = [];\n        for (const option of options) {\n            this.add(option);\n        }\n    }\n    get isVariable() {\n        for (const child of this.options) {\n            if (child.isVariable)\n                return true;\n        }\n        return false;\n    }\n    evalREString() {\n        const out = this.options.map((c) => c.toString).join(\"|\");\n        return this.options.length > 1 ? \"(\" + out + \")\" : out;\n    }\n    reverse() {\n        const out = this.options.map((c) => c.reverse());\n        return new Union(...out);\n    }\n    add(option) {\n        if (option.tag != RegexType.UNION || option.groupIndex >= 0) {\n            this.options.push(option);\n        }\n        else {\n            for (const opt of option.options) {\n                this.add(opt);\n            }\n        }\n        return this;\n    }\n    debugValue() {\n        return [\"Union\", { ...super.debugValue() }, this.options.map((c) => c.debugValue())];\n    }\n}\nexport var CharType;\n(function (CharType) {\n    CharType[CharType[\"AnyChar\"] = 1] = \"AnyChar\";\n    CharType[CharType[\"SingleChar\"] = 2] = \"SingleChar\";\n    CharType[CharType[\"CharRange\"] = 3] = \"CharRange\";\n    CharType[CharType[\"PropertyEscape\"] = 4] = \"PropertyEscape\";\n    CharType[CharType[\"CharClass\"] = 5] = \"CharClass\";\n    CharType[CharType[\"Union\"] = 6] = \"Union\";\n    CharType[CharType[\"Intersection\"] = 7] = \"Intersection\";\n})(CharType || (CharType = {}));\nexport class Char extends Regex {\n    constructor(op, neg = false) {\n        super();\n        this.op = op;\n        this.neg = neg;\n        this.tag = RegexType.CHAR;\n    }\n    match(ch) {\n        const result = this.matchChar(ch);\n        return (result && !this.neg) || (this.neg && !result);\n        return result;\n    }\n    reverse() {\n        return this;\n    }\n    debugValue() {\n        return this.toString + this.modifiers;\n    }\n}\nexport class LeafChar extends Char {\n    constructor(op, neg = false, args = []) {\n        super(op, neg);\n        this.op = op;\n        this.neg = neg;\n        this.args = args;\n    }\n    static Any(neg = false) {\n        return new LeafChar(CharType.AnyChar, neg);\n    }\n    static Class(charClass, neg = false) {\n        return new LeafChar(CharType.CharClass, neg, [charClass]);\n    }\n    static Single(ch, neg = false) {\n        if (typeof ch === \"string\") {\n            ch = ch.charCodeAt(0);\n        }\n        return new LeafChar(CharType.SingleChar, neg, [ch]);\n    }\n    static PropertyEscape(propNameOrId, propValueOrId, neg = false) {\n        if (typeof propNameOrId === \"string\")\n            propNameOrId = PropertyEscapes.propertyNameFor(propNameOrId);\n        if (typeof propValueOrId === \"string\")\n            propValueOrId = PropertyEscapes.propertyValueFor(propValueOrId);\n        return new LeafChar(CharType.PropertyEscape, neg, [propNameOrId, propValueOrId]);\n    }\n    matchChar(ch) {\n        const args = this.args;\n        switch (this.op) {\n            case CharType.SingleChar:\n                return ch == this.args[0];\n            case CharType.CharClass:\n                return CharClassHelpers[args[0]].matches(ch, false);\n            case CharType.PropertyEscape:\n                throw new Error(\"Property Escape Matching - TBD\");\n            default:\n                throw new Error(\"Custom Chars - TBD i: \" + this.op);\n        }\n        return false;\n    }\n    compareTo(another) {\n        if (this.op != another.op)\n            return this.op - another.op;\n        for (let i = 0; i < this.args.length && i < another.args.length; i++) {\n            if (this.args[i] != another.args[i])\n                return this.args[i] - another.args[i];\n        }\n        return this.args.length - another.args.length;\n    }\n    evalREString() {\n        if (this.op == CharType.AnyChar) {\n            return \".\";\n        }\n        else if (this.op == CharType.SingleChar) {\n            return stringRep(this.args[0]);\n        }\n        else if (this.op == CharType.CharClass) {\n            return CharClassHelpers[this.args[0]].reString(this.neg);\n        }\n        else if (this.op == CharType.PropertyEscape) {\n            return this.neg ? \"\\\\P{\" : \"\\\\p{\" + \"}\";\n            return `${PropertyEscapes.propertyNameString(this.args[0])}=${PropertyEscapes.propertyValueString(this.args[1])}\\}`;\n        }\n        return \"Custom \" + this.args.join(\" \");\n    }\n}\nexport class CharGroup extends Char {\n    constructor(op, neg = false, chars = []) {\n        super(op, neg);\n        this.op = op;\n        this.neg = neg;\n        this.chars = chars;\n    }\n    compareTo(another) {\n        if (this.op != another.op)\n            return this.op - another.op;\n        for (let i = 0; i < this.chars.length && i < another.chars.length; i++) {\n            const d = this.chars[i].compareTo(another.chars[i]);\n            if (d != 0)\n                return d;\n        }\n        return this.chars.length - another.chars.length;\n    }\n    matchChar(ch) {\n        const chars = this.chars;\n        switch (this.op) {\n            case CharType.CharRange:\n                return ch >= chars[0].args[0] && ch <= chars[1].args[0];\n            case CharType.Union: {\n                for (let i = 0; i < chars.length; i++) {\n                    if (chars[i].match(ch))\n                        return true;\n                }\n                return false;\n            }\n            case CharType.Intersection: {\n                for (let i = 0; i < chars.length; i++) {\n                    if (!chars[i].match(ch))\n                        return false;\n                }\n                return true;\n            }\n            default:\n                throw new Error(\"Custom CharGroup - TBD i: \" + this.op);\n        }\n        return false;\n    }\n    evalREString() {\n        const out = this.chars.map((ch) => ch.debugValue()).join(\"\");\n        if (this.op == CharType.CharRange) {\n            return `${this.chars[0].toString}-${this.chars[1].toString}`;\n        }\n        else if (this.op == CharType.Union) {\n            return out.length > 1 ? (this.neg ? \"[^\" : \"[\") + out + \"]\" : out;\n        }\n        else if (this.op == CharType.Intersection) {\n            return out.length > 1 ? (this.neg ? \"[^\" : \"[\") + out + \"]\" : out;\n        }\n        return \"Custom \" + this.chars.join(\" \");\n    }\n    static Range(start, end, neg = false) {\n        return new CharGroup(CharType.CharRange, neg, [start, end]);\n    }\n    static Union(neg = false, chars) {\n        return new CharGroup(CharType.Union, neg, chars);\n    }\n    static Intersection(neg = false, chars) {\n        return new CharGroup(CharType.Intersection, neg, chars);\n    }\n}\nexport class Var extends Regex {\n    constructor(name, reversed = false) {\n        super();\n        this.name = name;\n        this.reversed = reversed;\n        this.tag = RegexType.VAR;\n    }\n    reverse() {\n        return new Var(this.name, !this.reversed);\n    }\n    evalREString() {\n        return \"<\" + this.name + \">\";\n    }\n    debugValue() {\n        return [\"V:\" + this.name, { ...super.debugValue() }];\n    }\n}\nexport class BackNamedRef extends Regex {\n    constructor(name, reversed = false) {\n        super();\n        this.name = name;\n        this.reversed = reversed;\n        this.tag = RegexType.BACK_NAMED_REF;\n    }\n    reverse() {\n        return new BackNamedRef(this.name, !this.reversed);\n    }\n    evalREString() {\n        return \"\\\\k<\" + this.name + \">\";\n    }\n    debugValue() {\n        return { ...super.debugValue, BackRef: this.name };\n    }\n}\nexport class BackNumRef extends Regex {\n    constructor(num, reversed = false) {\n        super();\n        this.num = num;\n        this.reversed = reversed;\n        this.tag = RegexType.BACK_NUM_REF;\n    }\n    reverse() {\n        return new BackNumRef(this.num, !this.reversed);\n    }\n    evalREString() {\n        return \"\\\\\" + this.num;\n    }\n    debugValue() {\n        return \"\\\\\" + this.num;\n    }\n}\nexport class Rule {\n    constructor(expr, config) {\n        this.expr = expr;\n        this.skip = false;\n        config = config || {};\n        this.tag = config.tag || null;\n        if (config.priority == 0) {\n            this.priority = 0;\n        }\n        else {\n            this.priority = config.priority || 10;\n        }\n        if (config.matchIndex == 0) {\n            this.matchIndex = 0;\n        }\n        else {\n            this.matchIndex = config.matchIndex || -1;\n        }\n        this.skip = config.skip || false;\n        this.activeStates = config.activeStates || null;\n    }\n    stateCanActivate(state) {\n        return (this.activeStates == null ||\n            this.activeStates.size == 0 ||\n            this.activeStates.has(\"*\") ||\n            this.activeStates.has(state));\n    }\n    get needsSpecificStates() {\n        return this.activeStates != null && this.activeStates.size > 0 && !this.activeStates.has(\"*\");\n    }\n}\n//# sourceMappingURL=core.js.map","import * as TSU from \"@panyam/tsutils\";\nimport { LookAhead, Quant, RegexType, StartOfInput, EndOfInput, Cat, CharType, LeafChar, CharGroup, Var, Union, } from \"./core\";\nimport { CharClassType } from \"./charclasses\";\nimport { GroupCounter, isSpace } from \"./utils\";\nfunction advanceIf(tape, ch) {\n    const pos = tape.index;\n    for (let i = 0; i < ch.length; i++) {\n        if (tape.currCh != ch.charAt(i)) {\n            tape.index = pos;\n            return false;\n        }\n        tape.advance(1);\n    }\n    return true;\n}\nexport class RegexParser {\n    constructor() {\n        this.counter = new GroupCounter();\n    }\n    parse(pattern, ignoreSpaces = false, obCount = 0) {\n        const stack = [];\n        while (pattern.hasMore) {\n            const currCh = pattern.currCh;\n            if (advanceIf(pattern, \".\")) {\n                stack.push(LeafChar.Any());\n            }\n            else if (advanceIf(pattern, \"^\")) {\n                const x = new StartOfInput();\n                x.multiline = true;\n                stack.push(x);\n            }\n            else if (advanceIf(pattern, \"$\")) {\n                const x = new EndOfInput();\n                x.multiline = true;\n                stack.push(x);\n            }\n            else if (advanceIf(pattern, \"|\")) {\n                const prev = this.reduceLeft(stack);\n                const rest = this.parse(pattern, ignoreSpaces, obCount);\n                return new Union(prev, rest);\n            }\n            else if (currCh == \"[\") {\n                stack.push(this.parseCharGroup(pattern));\n            }\n            else if (currCh == \"*\" || currCh == \"?\" || currCh == \"+\" || currCh == \"{\") {\n                this.parseQuant(pattern, stack);\n            }\n            else if (ignoreSpaces && isSpace(currCh)) {\n                pattern.advance(1);\n            }\n            else if (ignoreSpaces && advanceIf(pattern, \"/*\")) {\n                while (pattern.currCh != \"*\" || pattern.nextCh != \"/\") {\n                    if (!pattern.hasMore) {\n                        this.throwError(pattern, \"Unterminated comment\");\n                    }\n                    pattern.advance(1);\n                }\n                pattern.advance(2);\n            }\n            else if (advanceIf(pattern, \"{-}\")) {\n                throw new Error(\"Intersection Not yet supported\");\n            }\n            else if (advanceIf(pattern, \"{+}\")) {\n                throw new Error(\"Union Not yet supported\");\n            }\n            else if (advanceIf(pattern, \"(\")) {\n                if (advanceIf(pattern, \"?\")) {\n                    if (advanceIf(pattern, \"#\")) {\n                        while (pattern.hasMore && pattern.currCh != \")\")\n                            pattern.advance(1);\n                        TSU.assert(advanceIf(pattern, \")\"), \"Expected ')'\");\n                    }\n                    else {\n                        let ignoreCase = false;\n                        let dotAll = false;\n                        let ignoreSpaces2 = ignoreSpaces;\n                        let neg = false;\n                        while (pattern.hasMore && pattern.currCh != \":\") {\n                            if (pattern.currCh == \"i\") {\n                                ignoreCase = neg ? false : true;\n                            }\n                            else if (pattern.currCh == \"s\") {\n                                dotAll = neg ? false : true;\n                            }\n                            else if (pattern.currCh == \"x\") {\n                                ignoreSpaces2 = neg ? false : true;\n                            }\n                            else if (pattern.currCh == \"-\") {\n                                neg = true;\n                            }\n                            pattern.advance(1);\n                        }\n                        TSU.assert(advanceIf(pattern, \":\"), \"Expected ':'\");\n                        const groupIndex = this.counter.next();\n                        let subExpr = this.parse(pattern, ignoreSpaces2, obCount + 1);\n                        if (subExpr.groupIndex >= 0) {\n                            subExpr = new Cat(subExpr);\n                        }\n                        subExpr.dotAll = dotAll;\n                        subExpr.ignoreCase = ignoreCase;\n                        subExpr.groupIndex = groupIndex;\n                        stack.push(subExpr);\n                        TSU.assert(advanceIf(pattern, \")\"), \"Expected ')'\");\n                    }\n                }\n                else {\n                    const groupIndex = this.counter.next();\n                    let subExpr = this.parse(pattern, ignoreSpaces, obCount + 1);\n                    if (subExpr.groupIndex >= 0) {\n                        subExpr = new Cat(subExpr);\n                    }\n                    subExpr.groupIndex = groupIndex;\n                    stack.push(subExpr);\n                    TSU.assert(advanceIf(pattern, \")\"), \"Expected ')'\");\n                }\n            }\n            else if (currCh == \")\") {\n                if (obCount == 0) {\n                    this.throwError(pattern, `Unmatched ${currCh}.  Try using \\\\${currCh}`);\n                }\n                break;\n            }\n            else if (currCh == \"]\" || currCh == \"}\") {\n                this.throwError(pattern, `Unmatched ${currCh}.  Try using \\\\${currCh}`);\n            }\n            else if (advanceIf(pattern, \"/\")) {\n                const prev = this.reduceLeft(stack);\n                const rest = this.parse(pattern, ignoreSpaces, obCount);\n                return new LookAhead(prev, rest, false);\n            }\n            else if (advanceIf(pattern, '\"')) {\n                while (pattern.currCh != '\"') {\n                    if (!pattern.hasMore) {\n                        this.throwError(pattern, \"Unterminated string\");\n                    }\n                    stack.push(this.parseChar(pattern));\n                }\n                pattern.advance(1);\n            }\n            else {\n                stack.push(this.parseChar(pattern));\n            }\n        }\n        if (stack.length == 1)\n            return stack[0];\n        return new Cat(...stack);\n    }\n    parseQuant(pattern, stack) {\n        let minCount = 1, maxCount = 1;\n        if (advanceIf(pattern, \"*\")) {\n            minCount = 0;\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (advanceIf(pattern, \"+\")) {\n            minCount = Math.min(minCount, 1);\n            maxCount = TSU.Constants.MAX_INT;\n        }\n        else if (advanceIf(pattern, \"?\")) {\n            minCount = 0;\n            maxCount = Math.max(maxCount, 1);\n        }\n        else if (advanceIf(pattern, \"{\")) {\n            let foundComma = false;\n            let p1 = \"\";\n            let p2 = \"\";\n            while (pattern.hasMore && pattern.currCh != \"}\") {\n                if (pattern.currCh == \",\")\n                    foundComma = true;\n                else {\n                    if (!foundComma)\n                        p1 += pattern.currCh;\n                    else\n                        p2 += pattern.currCh;\n                }\n                pattern.advance(1);\n            }\n            if (!pattern.hasMore) {\n                this.throwError(pattern, \"Invalid property escape\");\n            }\n            p1 = p1.trim();\n            p2 = p2.trim();\n            pattern.advance(1);\n            const part1 = parseInt(p1);\n            const part2 = parseInt(p2);\n            if (foundComma) {\n                minCount = isNaN(part1) ? 0 : part1;\n                maxCount = isNaN(part2) ? TSU.Constants.MAX_INT : part2;\n                if (minCount > maxCount) {\n                    this.throwError(pattern, `Invalid Quant /${p1},${p2}/: Min must be <= Max`);\n                }\n            }\n            else {\n                if (isNaN(part1)) {\n                    if (p1.length > 0) {\n                        stack.push(new Var(p1));\n                        return;\n                    }\n                    else {\n                        this.throwError(pattern, `Invalid quantifier: /${p1}/`);\n                    }\n                    minCount = maxCount = 1;\n                }\n                else {\n                    minCount = maxCount = part1;\n                }\n            }\n        }\n        else {\n            this.throwError(pattern, \"Expected '{', '*', '?' or '+', Found: \" + pattern.currCh);\n        }\n        if (stack.length <= 0) {\n            this.throwError(pattern, \"Quantifier cannot appear before an expression\");\n        }\n        const last = stack[stack.length - 1];\n        let quant;\n        if (last.tag == RegexType.QUANT && last.groupIndex < 0) {\n            quant = last;\n            quant.minCount = Math.min(minCount, quant.minCount);\n            quant.maxCount = Math.max(maxCount, quant.maxCount);\n        }\n        else {\n            quant = stack[stack.length - 1] = new Quant(last);\n            quant.minCount = minCount;\n            quant.maxCount = maxCount;\n        }\n        if (quant.greedy && advanceIf(pattern, \"?\")) {\n            quant.greedy = false;\n        }\n    }\n    parseCharGroup(pattern) {\n        const out = [];\n        TSU.assert(advanceIf(pattern, \"[\"), \"Expected '['\");\n        const neg = advanceIf(pattern, \"^\");\n        while (pattern.currCh != \"]\") {\n            const currch = this.parseChar(pattern);\n            if (advanceIf(pattern, \"-\")) {\n                if (pattern.hasMore) {\n                    if (pattern.currCh == \"]\" || pattern.currCh == \"[\") {\n                        out.push(currch);\n                        out.push(LeafChar.Single(\"-\"));\n                    }\n                    else {\n                        const endch = this.parseChar(pattern);\n                        if (currch.op != CharType.SingleChar || endch.op != CharType.SingleChar) {\n                            this.throwError(pattern, \"Char range cannot start or end in a char class\");\n                        }\n                        if (endch.args[0] < currch.args[0]) {\n                            this.throwError(pattern, \"End cannot be less than start\");\n                        }\n                        out.push(CharGroup.Range(currch, endch));\n                    }\n                }\n                else {\n                    this.throwError(pattern, \"Unterminated char class\");\n                }\n            }\n            else {\n                out.push(currch);\n            }\n        }\n        TSU.assert(advanceIf(pattern, \"]\"), \"']' expected\");\n        return CharGroup.Union(neg, out);\n    }\n    parseChar(pattern) {\n        if (pattern.currCh == \"\\\\\") {\n            return this.parseEscapeChar(pattern);\n        }\n        else {\n            return this.parseSingleChar(pattern);\n        }\n    }\n    parseSingleChar(pattern) {\n        const ch = pattern.currCh;\n        pattern.advance(1);\n        return LeafChar.Single(ch);\n    }\n    parsePropertyEscape(pattern) {\n        TSU.assert(advanceIf(pattern, \"\\\\{\"), \"Invalid property escape\");\n        pattern.advance(2);\n        let foundEq = false;\n        let propName = \"\";\n        let propValue = \"\";\n        while (pattern.hasMore && pattern.currCh != \"}\") {\n            if (pattern.currCh == \"=\")\n                foundEq = true;\n            else {\n                if (!foundEq)\n                    propName += pattern.currCh;\n                else\n                    propValue += pattern.currCh;\n            }\n            pattern.advance(1);\n        }\n        if (!pattern.hasMore) {\n            this.throwError(pattern, \"Invalid property escape\");\n        }\n        propName = propName.trim();\n        propValue = propValue.trim();\n        if (!foundEq) {\n            propValue = propName;\n            propName = \"General_Category\";\n        }\n        pattern.advance(1);\n        return LeafChar.PropertyEscape(propName, propValue);\n    }\n    parseEscapeChar(pattern) {\n        TSU.assert(advanceIf(pattern, \"\\\\\"), \"Expected '\\\\'\");\n        if (!pattern.hasMore) {\n            this.throwError(pattern, \"Encounted unexpected end of input after \\\\\");\n        }\n        if (advanceIf(pattern, \"w\")) {\n            return LeafChar.Class(CharClassType.WORD_CHAR);\n        }\n        else if (advanceIf(pattern, \"W\")) {\n            return LeafChar.Class(CharClassType.WORD_CHAR, true);\n        }\n        else if (advanceIf(pattern, \"d\")) {\n            return LeafChar.Class(CharClassType.DIGITS);\n        }\n        else if (advanceIf(pattern, \"D\")) {\n            return LeafChar.Class(CharClassType.DIGITS, true);\n        }\n        else if (advanceIf(pattern, \"s\")) {\n            return LeafChar.Class(CharClassType.SPACES);\n        }\n        else if (advanceIf(pattern, \"S\")) {\n            return LeafChar.Class(CharClassType.SPACES, true);\n        }\n        else if (advanceIf(pattern, \"0\")) {\n            return LeafChar.Single(\"\\0\");\n        }\n        else if (advanceIf(pattern, \"r\")) {\n            return LeafChar.Single(\"\\r\");\n        }\n        else if (advanceIf(pattern, \"n\")) {\n            return LeafChar.Single(\"\\n\");\n        }\n        else if (advanceIf(pattern, \"f\")) {\n            return LeafChar.Single(\"\\f\");\n        }\n        else if (advanceIf(pattern, \"b\")) {\n            return LeafChar.Single(\"\\b\");\n        }\n        else if (advanceIf(pattern, \"v\")) {\n            return LeafChar.Single(\"\\v\");\n        }\n        else if (advanceIf(pattern, \"t\")) {\n            return LeafChar.Single(\"\\t\");\n        }\n        else if (advanceIf(pattern, \"\\\\\")) {\n            return LeafChar.Single(\"\\\\\");\n        }\n        else if (advanceIf(pattern, \"'\")) {\n            return LeafChar.Single(\"'\");\n        }\n        else if (advanceIf(pattern, '\"')) {\n            return LeafChar.Single('\"');\n        }\n        else if (advanceIf(pattern, \"x\")) {\n            if (!pattern.hasMore) {\n                this.throwError(pattern, `Invalid hex sequence at ${pattern.index}`);\n            }\n            const hexSeq = pattern.currCh + pattern.nextCh;\n            const hexVal = parseInt(hexSeq, 16);\n            TSU.assert(!isNaN(hexVal), `Invalid hex sequence: '${hexSeq}'`);\n            pattern.advance(2);\n            return LeafChar.Single(hexVal);\n        }\n        else if (advanceIf(pattern, \"u\")) {\n            if (!pattern.canAdvance(3)) {\n                this.throwError(pattern, `Invalid unicode sequence at ${pattern.index}`);\n            }\n            const ucodeSeq = pattern.substring(pattern.index, pattern.index + 4);\n            const ucodeVal = parseInt(ucodeSeq, 16);\n            if (isNaN(ucodeVal)) {\n                this.throwError(pattern, `Invalid unicode sequence: '${ucodeSeq}'`);\n            }\n            pattern.advance(4);\n            return LeafChar.Single(ucodeVal);\n        }\n        const ch = pattern.currCh;\n        pattern.advance(1);\n        return LeafChar.Single(ch);\n    }\n    reduceLeft(stack) {\n        const r = stack.length == 1 ? stack[0] : new Cat(...stack);\n        stack.splice(0);\n        return r;\n    }\n    throwError(pattern, msg) {\n        throw new Error(msg);\n    }\n}\n//# sourceMappingURL=flexparser.js.map","export var CharClassType;\n(function (CharClassType) {\n    CharClassType[CharClassType[\"WORD_CHAR\"] = 0] = \"WORD_CHAR\";\n    CharClassType[CharClassType[\"DIGITS\"] = 1] = \"DIGITS\";\n    CharClassType[CharClassType[\"SPACES\"] = 2] = \"SPACES\";\n})(CharClassType || (CharClassType = {}));\nconst ZERO = \"0\".charCodeAt(0);\nconst NINE = \"9\".charCodeAt(0);\nconst lA = \"a\".charCodeAt(0);\nconst lZ = \"z\".charCodeAt(0);\nconst uA = \"A\".charCodeAt(0);\nconst uZ = \"Z\".charCodeAt(0);\nconst USCORE = \"_\".charCodeAt(0);\nexport class CharClassHelper {\n    matches(charCode, neg) {\n        const res = this.match(charCode);\n        return neg ? !res : res;\n    }\n}\nconst spaceChars = \" \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\";\nexport class Spaces extends CharClassHelper {\n    match(charCode) {\n        if (charCode >= 0x2000 && charCode <= 0x200a)\n            return true;\n        for (let i = 0; i < spaceChars.length; i++) {\n            if (spaceChars.charCodeAt(i) == charCode)\n                return true;\n        }\n        return false;\n    }\n    reString(neg) {\n        return neg ? \"\\\\S\" : \"\\\\s\";\n    }\n}\nexport class Digit extends CharClassHelper {\n    match(charCode) {\n        return charCode >= ZERO && charCode <= NINE;\n    }\n    reString(neg) {\n        return neg ? \"\\\\D\" : \"\\\\d\";\n    }\n}\nexport class WordChar extends CharClassHelper {\n    match(charCode) {\n        return (charCode == USCORE ||\n            (charCode >= ZERO && charCode <= NINE) ||\n            (charCode >= lA && charCode <= lZ) ||\n            (charCode >= uA && charCode <= uZ));\n        return true;\n    }\n    reString(neg) {\n        return neg ? \"\\\\W\" : \"\\\\w\";\n    }\n}\nexport const CharClassHelpers = [new WordChar(), new Digit(), new Spaces()];\n//# sourceMappingURL=charclasses.js.map","import { Rule, Regex } from \"./core\";\nimport { RegexParser as JSREParser } from \"./jsparser\";\nimport { RegexParser as FlexREParser } from \"./flexparser\";\nimport { Tape } from \"./tape\";\nexport function build(pattern, config) {\n    if (typeof pattern === \"string\") {\n        const rule = new Rule(exprFromJSRE(pattern, config), config);\n        rule.pattern = pattern;\n        return rule;\n    }\n    else if (pattern.constructor.name == \"RegExp\") {\n        const rule = new Rule(exprFromJSRE(pattern, config), config);\n        rule.pattern = pattern.source;\n        return rule;\n    }\n    else {\n        return new Rule(pattern, config);\n    }\n}\nexport function flatten(re, index = 0, rules) {\n    rules = rules || [];\n    if (typeof re === \"string\") {\n        rules.push(build(re, { tag: index }));\n    }\n    else if (re.constructor == RegExp) {\n        rules.push(build(re, { tag: index }));\n    }\n    else if (re.constructor == Rule) {\n        rules.push(re);\n    }\n    else if (re.constructor == Regex) {\n        rules.push(new Rule(re));\n    }\n    else {\n        const res = re;\n        for (let i = 0; i < res.length; i++) {\n            flatten(res[i], i, rules);\n        }\n    }\n    return rules;\n}\nexport function exprFromFlexRE(pattern) {\n    const parser = new FlexREParser();\n    try {\n        const expr = parser.parse(new Tape(pattern));\n        if (expr.dotAll == null)\n            expr.dotAll = false;\n        if (expr.multiline == null)\n            expr.multiline = false;\n        return expr;\n    }\n    catch (error) {\n        console.log(\"Error in FLEX RE: \", pattern);\n        throw error;\n    }\n}\nexport function exprFromJSRE(re, config) {\n    config = config || {};\n    const isRegExp = typeof re !== \"string\";\n    const pattern = typeof re === \"string\" ? re : re.source;\n    if (isRegExp)\n        config.unicode = re.unicode;\n    const expr = new JSREParser(pattern, config).parse();\n    if (typeof re !== \"string\") {\n        expr.dotAll = re.dotAll;\n        expr.ignoreCase = re.ignoreCase;\n        expr.multiline = re.multiline;\n    }\n    return expr;\n}\nexport function jsRE(strings, ...keys) {\n    const merged = String.raw(strings, ...keys);\n    return exprFromJSRE(merged);\n}\nexport function flexRE(strings, ...keys) {\n    const merged = String.raw(strings, ...keys);\n    return exprFromFlexRE(merged);\n}\n//# sourceMappingURL=builder.js.map"],"names":["RegexParser","constructor","pattern","config","this","counter","unicode","reduceLeft","stack","r","length","splice","throwError","msg","SyntaxError","parse","curr","end","currCh","push","Any","num","refNum","parseInt","current","gtPos","name","substring","trim","clPos","parseCharGroup","prev","rest","parseGroup","parseQuant","result","nchars","parseChar","depth","groupIndex","next","groupName","subExpr","after","neg","cond","groupIsSilent","expr","out","i","currch","Single","endch","op","SingleChar","args","Range","Union","index","parseEscapeChar","parseSingleChar","ch","charCodeAt","parsePropertyEscape","clEnd","eqPos","propStr","propName","propValue","parts","split","PropertyEscape","Class","WORD_CHAR","DIGITS","SPACES","hexSeq","hexVal","isNaN","ucodeSeq","ucodeVal","lastCh","minCount","maxCount","Math","min","max","Error","indexOf","sub","map","x","last","tag","QUANT","LOOK_AHEAD","LOOK_BACK","quant","greedy","Token","matchIndex","start","id","idCounter","value","groups","positions","state","lookahead","lookback","isOneOf","expected","tok","TokenBuffer","nextToken","tokenizerContext","buffer","tape","peek","consume","nth","match","matchFunc","ensure","nextAction","token","consumeIf","t","expectToken","ensureToken","nextMatches","toToken","m","floor","tapeIndex","gi","abs","BaseTokenizer","_prog","_vm","onError","allRules","onMatchHandlers","matchHandlersByValue","variables","Map","compiler","get","findRuleByValue","getVar","addVar","regex","currValue","set","find","add","onMatch","addRule","rule","on","prog","sortedRules","sortRules","compile","vm","VM","sort","r1","r2","priority","Tokenizer","super","arguments","getState","setState","reset","owner","hasMore","startIndex","startChar","err","skip","tokenize","tokens","offset","message","OpCode","isNewLineChar","Match","Prog","startCondition","scIsInclusive","instrs","stateMapping","registerState","has","size","opcode","char","Instr","initializer","debugValue","instrDebugValue","InstrDebugValue","instr","comment","c","join","Thread","gen","parentId","registers","regIncr","regId","regAcquire","regRelease","regValue","currState","forward","configs","threadCounter","currThreads","nextThreads","startPos","genForOffset","savePosition","thread","pos","jumpBy","delta","jumpTo","newOffset","forkTo","startGroup","newThread","endGroup","addThread","list","nextCh","Jump","Split","j","newOff","Save","tracer","threadQueued","GroupStart","GroupEnd","StartingChar","MLStartingChar","prevCh","EndingChar","MLEndingChar","StartOfWord","EndOfWord","RBegin","negate","groupStart","matchSuccess","matchEnd","recurseMatch","Begin","EnsureState","states","matchCurrPos","ignoreCase","currChCodeLower","currChCodeUpper","currChCode","charAt","startMatching","bestMatch","stepChar","startOffset","endOffset","savedPos","canAdvance","newPos","currMatch","nextMatch","stepThread","advance","threadStepped","advanceTape","End","currPriority","Char","CIChar","AnyNonNL","toString","TokenizerError","type","Object","setPrototypeOf","prototype","UnexpectedTokenError","foundToken","expectedTokens","Compiler","regexResolver","listener","emitGroups","emitPosition","rules","forEach","dotAll","multiline","needsSpecificStates","activeStates","ensureInstr","ind","compileExpr","currOffset","CHAR","compileChar","START_OF_INPUT","ml","END_OF_INPUT","START_OF_WORD","END_OF_WORD","CAT","compileCat","UNION","compileUnion","compileQuant","VAR","compileVar","BACK_NAMED_REF","compileBackNamedRef","BACK_NUM_REF","compileBackNumRef","compileLookAhead","compileLookBack","AnyChar","cat","child","children","ne","v","union","jumps","options","jmp","compileAtleast0","compileAtleast1","compileOptional","isUnlimited","l1","l3","l2","la","begin","lb","reverse","SimpleTokenizer","peekedToken","literals","matchers","addMatcher","matcher","addLiteral","lit","tokType","findIndex","k","kwd","toktype","matches","PropertyName","PropertyValue","propertyNameFor","propertyValueFor","propertyNameString","propertyValueString","TapeInterface","hasIndex","toLowerCase","toUpperCase","charCodeAtLower","charCodeAtUpper","Tape","input","_rawInput","content","endIndex","TapeHelper","advanceAfter","ensureNoPrefixSlash","advanceTo","lastIndex","currStart","numSlashes","prefix","success","RegexType","CharType","Regex","parent","reString","setOptions","isVariable","evalREString","modifiers","mod","StartOfInput","EndOfInput","Assertion","LookAhead","LookBack","Quant","Cat","opt","option","matchChar","LeafChar","charClass","CharClass","propNameOrId","propValueOrId","compareTo","another","String","fromCharCode","replace","CharGroup","chars","d","CharRange","Intersection","Var","reversed","BackNamedRef","BackRef","BackNumRef","Rule","stateCanActivate","advanceIf","ignoreSpaces","obCount","ignoreSpaces2","foundComma","p1","p2","part1","part2","foundEq","CharClassType","ZERO","NINE","lA","lZ","uA","uZ","USCORE","CharClassHelper","charCode","res","Spaces","spaceChars","Digit","WordChar","CharClassHelpers","build","exprFromJSRE","source","flatten","re","RegExp","exprFromFlexRE","parser","error","console","log","isRegExp","jsRE","strings","keys","raw","flexRE"],"ignoreList":[],"sourceRoot":""}